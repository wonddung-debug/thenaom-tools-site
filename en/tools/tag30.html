<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Auto Tagging — Line/Byte Interval · 3-value Rotation | Thenaom Tools</title>
  <meta name="description" content="Automatically insert tags into your text at fixed intervals. Use line intervals (e.g., every 30 lines) or byte intervals (e.g., every 1024 bytes), rotating up to 3 tag values. Supports insert-at-start, inline insertion, line-break control, and auto-saving." />
  <meta name="robots" content="index,follow" />
  <link rel="canonical" href="https://tools.thenaom.com/en/tools/tag30.html">
  <link rel="alternate" hreflang="en" href="https://tools.thenaom.com/en/tools/tag30.html">
  <link rel="alternate" hreflang="ko" href="https://tools.thenaom.com/tools/tag30.html">
  <link rel="alternate" hreflang="x-default" href="https://tools.thenaom.com/tools/tag30.html">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.png">

  <!-- Open Graph -->
  <meta property="og:title" content="Auto Tagging — Line/Byte Interval · 3-value Rotation" />
  <meta property="og:description" content="Insert up to 3 tags in rotation at fixed line or byte intervals." />
  <meta property="og:image" content="https://tools.thenaom.com/assets/og-tool-tag30-en.png" />
  <meta property="og:url" content="https://tools.thenaom.com/en/tools/tag30.html" />
  <meta property="og:type" content="website" />
  <meta property="og:locale" content="en_US" />

  <!-- Theme: set early to avoid FOUC -->
  <script>
    (function(){
      try{
        var saved=localStorage.getItem('theme');
        var mode=saved==='dark'?'dark':(saved==='light'?'light':(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches?'dark':'light'));
        document.documentElement.setAttribute('data-theme', mode);
        document.documentElement.setAttribute('data-user-theme', saved? '1':'');
      }catch(e){ document.documentElement.setAttribute('data-theme','light'); }
    })();
  </script>

  <!-- Google Tag Manager -->
  <script>
    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});
      var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:''; j.async=true;
      j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl; f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-N2BBPNCC');
  </script>

  <!-- AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3006330103681332" crossorigin="anonymous"></script>

  <style>
    :root{ --bg:#ffffff; --text:#0b1220; --muted:#475569; --border:#e5e7eb; --card:#ffffff; --accent:#2563eb; --btn-text:#ffffff; --shadow:0 6px 18px rgba(0,0,0,.06); --focus: color-mix(in srgb, var(--accent) 35%, transparent); --hero-tint:#eff3ff; --hero-grid:#e8ecf6; --hero-ring:#cfe1ff; --input:#0b1220; --input-bg:var(--card); }
    [data-theme="dark"]{ --bg:#0b1220; --text:#f1f5f9; --muted:#cbd5e1; --border:#334155; --card:#111827; --accent:#60a5fa; --btn-text:#0b1220; --shadow:0 8px 22px rgba(0,0,0,.55); --focus: color-mix(in srgb, var(--accent) 45%, transparent); --hero-tint:#0f172a; --hero-grid:#162036; --hero-ring:#1f3b76; --input:#e5e7eb; --input-bg:#0f172a; }
    html,body{background:var(--bg)!important}
    body{color:var(--text)!important;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,Arial,sans-serif}
    a{color:var(--accent);text-decoration:none}
    .container{max-width:1120px;margin:0 auto;padding:0 16px}

    /* Header */
    header.site{position:sticky;top:0;z-index:100;background:var(--bg)!important;border-bottom:1px solid var(--border)}
    .brand{color:var(--text)!important;font-weight:800;text-decoration:none}
    header.site nav{display:flex;align-items:center;gap:12px}
    .lang-switch,.theme-toggle,.btn{padding:.5rem .72rem;border:1px solid var(--border);border-radius:.7rem;background:linear-gradient(180deg,color-mix(in srgb,var(--card)96%,transparent),var(--card));cursor:pointer;color:var(--text)!important;box-shadow:var(--shadow);transition:transform .06s,box-shadow .18s,border-color .18s,background .18s}
    .lang-switch:hover,.theme-toggle:hover,.theme-toggle:focus-visible,.btn:hover{color:var(--accent)!important;border-color:var(--accent)!important;box-shadow:0 0 0 3px var(--focus), var(--shadow)}
    .theme-toggle:active,.btn:active{transform:translateY(1px)}
    .theme-toggle[aria-pressed="true"]{background:linear-gradient(180deg,color-mix(in srgb,var(--accent)22%,var(--card)),var(--accent));border-color:var(--accent)!important;color:var(--btn-text)!important}

    /* Hero */
    .hero{position:relative;overflow:hidden;padding:28px 0 18px;text-align:start;isolation:isolate}
    .hero::before{content:"";position:absolute;inset:0;background:radial-gradient(900px 360px at 50% -15%, var(--hero-ring), transparent 65%),linear-gradient(180deg, color-mix(in srgb, var(--hero-tint) 88%, transparent), transparent 60%);z-index:-2}
    .hero::after{content:"";position:absolute;inset:0;background:linear-gradient(to right, color-mix(in srgb,var(--hero-grid) 35%, transparent) 1px, transparent 1px) 0 0/28px 28px,linear-gradient(to bottom, color-mix(in srgb,var(--hero-grid) 35%, transparent) 1px, transparent 1px) 0 0/28px 28px;opacity:.5;z-index:-1}
    .hero h1{margin:0;font-size:clamp(1.6rem,3.4vw,2.2rem)}
    .hero p{margin:.4rem 0 0;color:var(--muted);max-width:900px}
    .crumb{margin:10px 0 0;font-size:.95rem}
    .crumb a{color:var(--muted)}
    .hl{background:color-mix(in srgb, var(--accent) 14%, transparent);padding:0 4px;border-radius:6px}

    /* Main layout */
    main .section{margin:12px 0}
    .ad-space{margin:8px 0}
    .panel{border:1px solid var(--border);border-radius:12px;background:linear-gradient(180deg, color-mix(in srgb, var(--card) 95%, transparent), var(--card));box-shadow:var(--shadow);padding:12px}
    .panel h2{margin:.1rem 0 .6rem;font-size:1.06rem}
    .row{display:grid;grid-template-columns:1fr;gap:12px}
    @media(min-width:980px){.row{grid-template-columns:1fr 1fr}}
    .controls{display:flex;flex-wrap:wrap;gap:8px}
    .controls .btn-primary{background:linear-gradient(180deg,color-mix(in srgb,var(--accent)18%,var(--card)),var(--accent));color:var(--btn-text)!important;border-color:var(--accent)}
    .controls .btn-secondary{background:linear-gradient(180deg, color-mix(in srgb, var(--card) 95%, transparent), var(--card))}
    textarea.input, textarea.output{ width:100%;min-height:260px;padding:12px;border-radius:10px;border:1px solid var(--border); background:var(--input-bg);color:var(--input);font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.98rem;line-height:1.45;resize:vertical }
    input[type="number"]{width:120px}
    .small{font-size:.92rem;color:var(--muted)}
    .counter{display:flex;gap:12px;flex-wrap:wrap;color:var(--muted);font-size:.92rem;margin-top:6px}
    .options{display:flex;flex-wrap:wrap;gap:14px}
    .opt{display:flex;align-items:center;gap:6px}
    .opt .hint{font-size:.9em;color:var(--muted)}
    .notice{border-left:3px solid var(--accent);padding:8px 10px;background:color-mix(in srgb, var(--card) 92%, transparent);border-radius:8px}

    footer.site{margin-top:16px;padding:14px 0;border-top:1px solid var(--border);font-size:.95rem;color:var(--muted)!important}
    .footer-row{display:flex;justify-content:space-between;gap:12px;align-items:center;flex-wrap:wrap}
    .footer-links{display:flex;gap:14px;flex-wrap:wrap}
    .footer-links a{color:var(--muted);text-decoration:none}
    .footer-links a:hover{color:var(--accent)}
  </style>
</head>
<body>
  <!-- GTM (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-N2BBPNCC" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

  <!-- Header -->
  <header class="site">
    <div class="container" style="display:flex;justify-content:space-between;align-items:center">
      <a href="/en/" class="brand">Thenaom Tools</a>
      <nav aria-label="Secondary navigation">
        <a class="lang-switch" href="/tools/tag30.html" hreflang="ko">한국어</a>
        <button id="themeToggle" class="theme-toggle" aria-pressed="false" title="Toggle theme"><span class="icon">🌞</span><span class="label">Light</span></button>
      </nav>
    </div>
  </header>

  <!-- Hero -->
  <section class="hero">
    <div class="container">
      <div class="crumb"><a href="/en/">Home</a> &nbsp;>&nbsp; <a href="/utility/">Utilities</a> &nbsp;>&nbsp; Auto Tagging</div>
      <h1>Auto Tagging (Line/Byte) · 3-value Rotation</h1>
      <p>Automatically insert <span class="hl">up to three tags in rotation</span> into your text. Choose line-based (e.g., every 30 lines) or byte-based (e.g., every 1024 bytes) insertion.</p>
    </div>
  </section>

  <main class="container" id="main">
    <!-- Top ad -->
    <div class="ad-space">
      <ins class="adsbygoogle" style="display:block"
           data-ad-client="ca-pub-3006330103681332"
           data-ad-slot="6703005412"
           data-ad-format="auto"
           data-full-width-responsive="true"></ins>
    </div>
    <script>(adsbygoogle=window.adsbygoogle||[]).push({});</script>

    <!-- How to -->
    <section class="section panel">
      <h2>How to use</h2>
      <p class="small">1) Paste your text → 2) Set intervals & tags → 3) <strong>Run</strong> (shortcut: <kbd>Ctrl</kbd>/<kbd>⌘</kbd> + <kbd>Enter</kbd>)</p>
    </section>

    <!-- Body -->
    <section class="section">
      <div class="row">
        <!-- Input -->
        <div class="panel" aria-label="Input">
          <h2>Input</h2>
          <textarea id="input" class="input" placeholder="Paste your text here"></textarea>
          <div class="counter" id="inStats" aria-live="polite"></div>
        </div>

        <!-- Options / Output -->
        <div class="panel" aria-label="Options and output">
          <h2>Options & Run</h2>

          <div class="options" style="margin-bottom:8px">
            <!-- Common quick options -->
            <label class="opt"><input type="checkbox" id="insertAtStart"> Insert tag at beginning</label>
            <label class="opt"><input type="checkbox" id="inlineInsert"> Inline insert (no line break)</label>
            <label class="opt"><input type="checkbox" id="addNewlineAfter"> Add line break after tag</label>

            <!-- Mode -->
            <fieldset class="opt" style="border:none;padding:0;margin:0;display:flex;gap:10px;flex-wrap:wrap">
              <legend class="hidden-visually">Mode</legend>
              <label class="opt"><input type="radio" name="mode" value="line" checked> <strong>Line interval</strong> (e.g., 30 lines)</label>
              <label class="opt"><input type="radio" name="mode" value="byte"> <strong>Byte interval</strong> (e.g., 1024 bytes)</label>
            </fieldset>

            <!-- Line interval options -->
            <div id="lineOpts" class="opt" style="flex-direction:column;gap:8px">
              <label class="opt">Interval (lines)
                <input id="lineInterval" type="number" value="30" min="1">
              </label>
              <label class="opt">Skip first lines
                <input id="lineStartOffset" type="number" value="0" min="0">
                <span class="hint">0 means: 30 lines → insert at line 31 first</span>
              </label>
              <label class="opt">Insert position
                <select id="lineInsertWhere">
                  <option value="newline">Insert as a new line (default)</option>
                  <option value="append">Append to end of current line</option>
                  <option value="prepend">Prepend to start of current line</option>
                </select>
              </label>
            </div>

            <!-- Byte interval options -->
            <div id="byteOpts" class="opt" style="flex-direction:column;gap:8px;display:none">
              <label class="opt">Interval (bytes)
                <input id="byteInterval" type="number" value="1024" min="1">
              </label>
              <label class="opt">Skip first bytes
                <input id="byteStartOffset" type="number" value="0" min="0">
              </label>
              <label class="opt">Mode
                <select id="byteMode">
                  <option value="friendly">Friendly (insert at start of next line)</option>
                  <option value="exact">Exact byte position</option>
                </select>
              </label>
              <label class="opt" id="byteExactSideWrap" style="display:none">Exact insert side
                <select id="byteExactSide">
                  <option value="after">After boundary</option>
                  <option value="before">Before boundary</option>
                </select>
              </label>
            </div>

            <!-- Tags & Template -->
            <fieldset class="opt" style="border:1px dashed var(--border);border-radius:10px;padding:10px;display:flex;flex-direction:column;gap:8px">
              <legend class="small" style="padding:0 6px">Tag values (up to 3, rotate)</legend>
              <label class="opt">Tag 1 <input id="tag1" type="text" placeholder="[A]"></label>
              <label class="opt">Tag 2 <input id="tag2" type="text" placeholder="[B]"></label>
              <label class="opt">Tag 3 <input id="tag3" type="text" placeholder="[C]"></label>
              <label class="opt">Template (where the tag goes)
                <input id="template" type="text" value="{TAG}">
                <span class="hint">{TAG} is replaced by your tag value. Add your own spaces/brackets if needed. e.g., <code>--{TAG}--</code>, <code> [{TAG}]</code></span>
              </label>
              <label class="opt"><input type="checkbox" id="avoidDup" checked> Avoid duplicates (skip when the same tag is already there)</label>
              <label class="opt"><input type="checkbox" id="trimInserted"> Trim whitespace on the inserted tag line</label>
            </fieldset>

            <!-- Newline normalization -->
            <label class="opt">Normalize line endings
              <select id="newline">
                <option value="as-is">Keep as-is</option>
                <option value="lf">LF (Unix/macOS)</option>
                <option value="crlf">CRLF (Windows)</option>
              </select>
            </label>
          </div>

          <div class="controls" style="margin-bottom:10px">
            <button class="btn btn-primary" id="runBtn">Run</button>
            <button class="btn btn-secondary" id="resetBtn">Reset</button>
            <button class="btn btn-secondary" id="copyBtn">Copy</button>
            <button class="btn btn-secondary" id="downloadBtn">Download</button>
          </div>

          <textarea id="output" class="output" placeholder="The result will appear here" aria-live="polite" readonly></textarea>
          <div class="counter" id="outStats" aria-live="polite"></div>

          <p class="small notice" style="margin-top:10px">
            👉 <strong>Tip</strong>: No automatic spaces are added. If you want a space, include it in your template or tag (e.g., template <code> {TAG}</code> to add one leading space).
          </p>
        </div>
      </div>
    </section>

    <!-- Bottom ad -->
    <div class="ad-space">
      <ins class="adsbygoogle" style="display:block"
           data-ad-client="ca-pub-3006330103681332"
           data-ad-slot="9867638073"
           data-ad-format="auto"
           data-full-width-responsive="true"></ins>
    </div>
    <script>(adsbygoogle=window.adsbygoogle||[]).push({});</script>

    <!-- FAQ -->
    <section class="section panel faq">
      <h2>FAQ</h2>
      <div class="qa"><h3>What’s the difference between line and byte intervals?</h3><p>Line mode counts lines (e.g., every 30 lines). Byte mode counts UTF‑8 bytes (e.g., every 1024 bytes). Note that many non‑ASCII characters occupy multiple bytes.</p></div>
      <div class="qa"><h3>“Friendly” vs “Exact” in byte mode</h3><p><b>Friendly</b> snaps to the <b>start of the next line</b>, keeping text readable. <b>Exact</b> inserts at the exact byte boundary (without splitting multibyte characters).</p></div>
      <div class="qa"><h3>Insert tag at beginning</h3><p>When enabled, the first tag (with your template applied) is inserted at the very start (byte 0 / line 1). With “avoid duplicates” on, it skips if the text already starts with the same tag.</p></div>
      <div class="qa"><h3>Inline insert (no line break)</h3><p>Append the tag directly to the current line instead of creating a new line. No spaces are added automatically—add them in your template if needed.</p></div>
      <div class="qa"><h3>Add line break after tag</h3><p>Forces a newline right after every inserted tag. Combining with inline insert gives <code>...text{TAG}\nNext line...</code>.</p></div>
      <div class="qa"><h3>What does the <code>{TAG}</code> placeholder do?</h3><p><code>{TAG}</code> is replaced with your Tag 1/2/3 values in rotation. Example: template <code>--{TAG}--</code> with Tag 1 = <code>[A]</code> becomes <code>--[A]--</code>.</p></div>
      <div class="qa"><h3>Skip first lines/bytes</h3><p>Skip a header or front matter: start tagging after the first N lines/bytes.</p></div>
      <div class="qa"><h3>Avoid duplicates & Trim</h3><p>Avoid duplicates skips insertion if the exact tag text is already present at that point. Trim removes leading/trailing whitespace on the inserted tag line.</p></div>
      <div class="qa"><h3>Normalize line endings (LF/CRLF)</h3><p>Different OSes use different line breaks. Normalize them to avoid formatting issues across platforms.</p></div>
      <div class="qa"><h3>How does 3‑tag rotation work?</h3><p>They cycle as Tag 1 → Tag 2 → Tag 3 → Tag 1… Empty tag fields are skipped.</p></div>
      <div class="qa"><h3>Are my settings saved?</h3><p>Yes. Options and tag values are saved to <code>localStorage</code> and restored on reload. Use Reset to clear.</p></div>
      <div class="qa"><h3>Is it safe with UTF‑8 characters?</h3><p>Yes. In Exact mode, insertion only happens at UTF‑8 code point boundaries—no character is ever split.</p></div>
    </section>

    <!-- Contact -->
    <section class="section contact panel" aria-label="Contact">
      <h2>Contact</h2>
      <p class="small">Questions or suggestions? Email us.</p>
      <p><strong>Email:</strong> <a href="mailto:thenaom@naver.com">thenaom@naver.com</a></p>
    </section>
  </main>

  <!-- Footer -->
  <footer class="site">
    <div class="container footer-row">
      <div>© <span id="y"></span> Thenaom Tools. All rights reserved.</div>
      <nav class="footer-links" aria-label="Footer links">
        <a href="/privacy.html">Privacy Policy</a>
        <a href="/terms.html">Terms</a>
        <a href="#" id="cookiePrefs">Cookie Settings</a>
        <a href="/sitemap.xml">Sitemap</a>
        <a href="/ads.txt">ads.txt</a>
        <a href="mailto:thenaom@naver.com">Contact</a>
      </nav>
    </div>
  </footer>

  <script>
    // year
    document.getElementById('y').textContent = new Date().getFullYear();

    // theme toggle (robust)
    (function(){
      const btn=document.getElementById('themeToggle');
      const root=document.documentElement;
      const get=()=> (root.getAttribute('data-theme')==='dark'?'dark':'light');
      const setUI=(m)=>{ if(!btn) return; btn.setAttribute('aria-pressed',m==='dark'); const ic=btn.querySelector('.icon'); const lb=btn.querySelector('.label'); if(ic) ic.textContent=m==='dark'?'🌙':'🌞'; if(lb) lb.textContent=m==='dark'?'Dark':'Light'; };
      setUI(get());
      btn&&btn.addEventListener('click',()=>{ const next=get()==='dark'?'light':'dark'; root.setAttribute('data-theme',next); try{localStorage.setItem('theme',next);}catch(e){} setUI(next); });
      const mq=window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
      if(mq && !localStorage.getItem('theme')){ mq.addEventListener('change',e=>{ const m=e.matches?'dark':'light'; root.setAttribute('data-theme',m); setUI(m); }); }
    })();

    // helpers
    function byteLen(str){ return new TextEncoder().encode(str).length; }
    function countLines(str){ if(!str) return 0; return str.split(/\r\n|\r|\n/).length; }
    function statHtml(str){ return `<span>Lines: ${countLines(str).toLocaleString()}</span><span>Bytes: ${byteLen(str).toLocaleString()}</span><span>Chars: ${[...str].length.toLocaleString()}</span>`; }
    function normalizeNewlines(text){ return text.replace(/\r\n?|\n/g, '\n'); }
    function safeTemplate(tpl, tag){ return (tpl||'{TAG}').replaceAll('{TAG}', tag); }

    // UTF-8 map helpers
    function buildUtf8Map(str){
      const enc = new TextEncoder();
      const bytes = enc.encode(str);
      const map = [];
      let byteOffset = 0;
      for(const ch of str){ map.push(byteOffset); byteOffset += enc.encode(ch).length; }
      const lineStarts = [0];
      for(let i=0;i<str.length;i++){ if(str[i]==='\n'){ const nextOff = enc.encode(str.slice(0, i+1)).length; lineStarts.push(nextOff); } }
      return {bytes, map, lineStarts};
    }
    function findCodepointStartAtOrBeforeByte(map, bytesLen, pos){ if(pos<=0) return 0; if(pos>=bytesLen) return bytesLen; let lo=0, hi=map.length-1, best=0; while(lo<=hi){ const mid=(lo+hi)>>1; const off=map[mid]; if(off===pos) return off; if(off<pos){ best=off; lo=mid+1; } else hi=mid-1; } return best; }
    function findNextLineStartOffset(lineStarts, pos){ for(const off of lineStarts){ if(off>pos) return off; } return null; }

    // LINE MODE
    function processLineMode(input, opts){
      const NL_IN = (input.match(/\r\n/g) ? '\r\n' : (input.indexOf('\r')>-1 && input.indexOf('\n')===-1 ? '\r' : '\n'));
      const lf = normalizeNewlines(input);
      let lines = lf.split('\n');
      const out = [];
      const tags = opts.tags; let ti = 0;
      const interval = Math.max(1, opts.lineInterval|0);
      const startOffset = Math.max(0, opts.lineStartOffset|0);
      const where = opts.lineInsertWhere; // newline, append, prepend

      // insert at beginning
      if(opts.insertAtStart){
        const tag0 = safeTemplate(opts.template, tags[ti % tags.length]); ti++;
        const tag0Text = opts.inlineInsert ? (tag0 + (opts.addNewlineAfter?'\n':'')) : (opts.addNewlineAfter? (tag0+'\n') : tag0);
        if(opts.inlineInsert || where==='append'){
          if(!lines.length) lines=[''];
          lines[0] = lines[0] + tag0Text;
        }else if(where==='prepend'){
          if(!lines.length) lines=[''];
          lines[0] = tag0Text + lines[0];
        }else{
          out.push(tag0Text.replace(/\n$/,''));
        }
      }

      for(let i=0;i<lines.length;i++){
        let line = lines[i];
        const lineNum = i + 1;
        const shouldInsert = (lineNum > startOffset) && ((lineNum - startOffset) % interval === 0);
        if(!shouldInsert){ out.push(line); continue; }
        const tag = safeTemplate(opts.template, tags[ti % tags.length]); ti++;
        const tagText = opts.inlineInsert ? (tag + (opts.addNewlineAfter?'\n':'')) : (opts.addNewlineAfter? (tag+'\n') : tag);
        if(where==='newline' && !opts.inlineInsert){
          out.push(line);
          out.push(tagText.replace(/\n$/,''));
        }else if(where==='append' || opts.inlineInsert){
          out.push(line + tagText);
        }else{ // prepend
          out.push(tagText + line);
        }
      }
      let joined = out.join('\n');
      if(opts.newline==='lf') return joined.replace(/\r\n|\r|\n/g,'\n');
      if(opts.newline==='crlf') return joined.replace(/\r\n|\r|\n/g,'\r\n');
      return joined.replace(/\n/g, NL_IN==='\r\n'?'\r\n':(NL_IN==='\r'?'\r':'\n'));
    }

    // BYTE MODE (interval measured on original text; tags do not shift the next interval)
    function processByteMode(input, opts){
      const enc = new TextEncoder();
      const dec = new TextDecoder();
      const {bytes, map, lineStarts} = buildUtf8Map(input);
      const tags = opts.tags; let ti = 0;
      const interval = Math.max(1, opts.byteInterval|0);
      let pos = Math.max(0, opts.byteStartOffset|0) + interval;

      const chunks = [];
      let cursor = 0;
      const addChunk = (from, to) => { if(to>from) chunks.push(new Uint8Array(bytes.slice(from, to))); };

      // insert at beginning
      if(opts.insertAtStart){
        const tag0 = safeTemplate(opts.template, tags[ti % tags.length]); ti++;
        const tag0Text = opts.inlineInsert ? (tag0 + (opts.addNewlineAfter?'\n':'')) : (opts.addNewlineAfter? (tag0+'\n') : tag0);
        const tag0Bytes = enc.encode(tag0Text);
        let skip0=false; if(opts.avoidDup){ const slice0 = new Uint8Array(bytes.slice(0, tag0Bytes.length)); if(slice0.length===tag0Bytes.length){ let eq=true; for(let i=0;i<tag0Bytes.length;i++){ if(tag0Bytes[i]!==slice0[i]){ eq=false; break; } } if(eq) skip0=true; } }
        if(!skip0) chunks.push(tag0Bytes);
      }

      while(pos <= bytes.length){
        let insertAtByte = 0;
        if(opts.byteMode==='friendly'){
          const nextLineStart = findNextLineStartOffset(lineStarts, pos);
          if(nextLineStart==null){ break; }
          insertAtByte = nextLineStart;
        }else{
          insertAtByte = findCodepointStartAtOrBeforeByte(map, bytes.length, pos);
          if(opts.byteExactSide==='after'){
            for(let i=0;i<map.length;i++){ if(map[i]>insertAtByte){ insertAtByte = map[i]; break; } }
          }
        }
        const tag = safeTemplate(opts.template, tags[ti % tags.length]); ti++;
        const tagText = opts.inlineInsert ? (tag + (opts.addNewlineAfter?'\n':'')) : (opts.addNewlineAfter? (tag+'\n') : tag);
        const tagBytes = enc.encode(tagText);

        let skip=false; if(opts.avoidDup){ const nextSlice = new Uint8Array(bytes.slice(insertAtByte, insertAtByte + tagBytes.length)); if(nextSlice.length===tagBytes.length){ let eq=true; for(let i=0;i<tagBytes.length;i++){ if(tagBytes[i]!==nextSlice[i]){ eq=false; break; } } if(eq) skip=true; } }

        addChunk(cursor, insertAtByte);
        if(!skip) chunks.push(tagBytes);
        cursor = insertAtByte;
        pos = insertAtByte + interval;
      }
      addChunk(cursor, bytes.length);

      let total=0; for(const c of chunks) total+=c.length;
      const out = new Uint8Array(total);
      let off=0; for(const c of chunks){ out.set(c, off); off+=c.length; }
      let text = dec.decode(out);
      if(opts.newline==='lf') text = text.replace(/\r\n|\r|\n/g,'\n');
      if(opts.newline==='crlf') text = text.replace(/\r\n|\r|\n/g,'\r\n');
      return text;
    }

    // DOM refs
    const $in = document.getElementById('input');
    const $out = document.getElementById('output');
    const $inStats = document.getElementById('inStats');
    const $outStats = document.getElementById('outStats');
    const $run = document.getElementById('runBtn');
    const $reset = document.getElementById('resetBtn');
    const $copy = document.getElementById('copyBtn');
    const $download = document.getElementById('downloadBtn');

    const $mode = () => document.querySelector('input[name="mode"]:checked')?.value || 'line';
    const $lineInterval = document.getElementById('lineInterval');
    const $lineStartOffset = document.getElementById('lineStartOffset');
    const $lineInsertWhere = document.getElementById('lineInsertWhere');

    const $byteInterval = document.getElementById('byteInterval');
    const $byteStartOffset = document.getElementById('byteStartOffset');
    const $byteMode = document.getElementById('byteMode');
    const $byteExactSideWrap = document.getElementById('byteExactSideWrap');
    const $byteExactSide = document.getElementById('byteExactSide');

    const $tag1 = document.getElementById('tag1');
    const $tag2 = document.getElementById('tag2');
    const $tag3 = document.getElementById('tag3');
    const $template = document.getElementById('template');
    const $avoidDup = document.getElementById('avoidDup');
    const $trimInserted = document.getElementById('trimInserted');

    const $newline = document.getElementById('newline');

    const $insertAtStart = document.getElementById('insertAtStart');
    const $inlineInsert = document.getElementById('inlineInsert');
    const $addNewlineAfter = document.getElementById('addNewlineAfter');

    const $lineOpts = document.getElementById('lineOpts');
    const $byteOpts = document.getElementById('byteOpts');

    function updateInStats(){ $inStats.innerHTML = statHtml($in.value); toggleRun(); }
    function updateOutStats(){ $outStats.innerHTML = statHtml($out.value); }
    function toggleRun(){ const enabled = !!$in.value; $run.disabled = !enabled; $run.style.opacity = enabled ? '1' : '.6'; $run.style.cursor = enabled ? 'pointer' : 'not-allowed'; }

    function run(){
      if(!$in.value) return;
      const tags = [$tag1.value,$tag2.value,$tag3.value].filter(Boolean);
      if(tags.length===0){ alert('Enter at least one tag.'); return; }
      const common = {
        tags,
        template: $template.value || '{TAG}',
        avoidDup: $avoidDup.checked,
        trimInserted: $trimInserted.checked,
        newline: $newline.value,
        insertAtStart: $insertAtStart.checked,
        inlineInsert: $inlineInsert.checked,
        addNewlineAfter: $addNewlineAfter.checked
      };
      let result='';
      if($mode()==='line'){
        result = processLineMode($in.value, Object.assign(common, {
          lineInterval: parseInt($lineInterval.value||'30',10),
          lineStartOffset: parseInt($lineStartOffset.value||'0',10),
          lineInsertWhere: $lineInsertWhere.value
        }));
      }else{
        result = processByteMode($in.value, Object.assign(common, {
          byteInterval: parseInt($byteInterval.value||'1024',10),
          byteStartOffset: parseInt($byteStartOffset.value||'0',10),
          byteMode: $byteMode.value,
          byteExactSide: $byteExactSide.value
        }));
      }
      $out.value = result;
      updateOutStats();
      window.dataLayer = window.dataLayer || [];
      window.dataLayer.push({event:'run_click', tool:'tag30', options:{mode:$mode(), lineInt:$lineInterval.value, byteInt:$byteInterval.value}});
    }

    // autosave / autoload
    function save(){
      const data={
        tag1:$tag1.value, tag2:$tag2.value, tag3:$tag3.value, template:$template.value,
        avoidDup:$avoidDup.checked, trimInserted:$trimInserted.checked,
        newline:$newline.value, mode:$mode(),
        lineInterval:$lineInterval.value, lineStartOffset:$lineStartOffset.value, lineInsertWhere:$lineInsertWhere.value,
        byteInterval:$byteInterval.value, byteStartOffset:$byteStartOffset.value, byteMode:$byteMode.value, byteExactSide:$byteExactSide.value,
        insertAtStart:$insertAtStart.checked, inlineInsert:$inlineInsert.checked, addNewlineAfter:$addNewlineAfter.checked
      };
      try{ localStorage.setItem('tag30_opts_en', JSON.stringify(data)); }catch(e){}
    }
    function load(){
      const raw = localStorage.getItem('tag30_opts_en'); if(!raw) return;
      try{
        const o = JSON.parse(raw);
        if(o.tag1!==undefined) $tag1.value=o.tag1; if(o.tag2!==undefined) $tag2.value=o.tag2; if(o.tag3!==undefined) $tag3.value=o.tag3;
        if(o.template!==undefined) $template.value=o.template;
        if(o.avoidDup!==undefined) $avoidDup.checked=o.avoidDup; if(o.trimInserted!==undefined) $trimInserted.checked=o.trimInserted;
        if(o.newline) $newline.value=o.newline;
        if(o.lineInterval) $lineInterval.value=o.lineInterval; if(o.lineStartOffset) $lineStartOffset.value=o.lineStartOffset; if(o.lineInsertWhere) $lineInsertWhere.value=o.lineInsertWhere;
        if(o.byteInterval) $byteInterval.value=o.byteInterval; if(o.byteStartOffset) $byteStartOffset.value=o.byteStartOffset; if(o.byteMode) $byteMode.value=o.byteMode; if(o.byteExactSide) $byteExactSide.value=o.byteExactSide;
        if(o.insertAtStart!==undefined) $insertAtStart.checked=o.insertAtStart; if(o.inlineInsert!==undefined) $inlineInsert.checked=o.inlineInsert; if(o.addNewlineAfter!==undefined) $addNewlineAfter.checked=o.addNewlineAfter;
        if(o.mode==='byte') document.querySelector('input[name="mode"][value="byte"]').checked=true;
      }catch(e){}
    }

    function syncModeUI(){
      const m=$mode();
      $lineOpts.style.display = (m==='line')?'':'none';
      $byteOpts.style.display = (m==='byte')?'':'none';
      document.getElementById('byteExactSideWrap').style.display = ($byteMode.value==='exact')? '' : 'none';
    }

    [$tag1,$tag2,$tag3,$template,$avoidDup,$trimInserted,$newline,$lineInterval,$lineStartOffset,$lineInsertWhere,$byteInterval,$byteStartOffset,$byteMode,$byteExactSide,$insertAtStart,$inlineInsert,$addNewlineAfter].forEach(el=>{
      el.addEventListener('input', save);
      el.addEventListener('change', save);
    });

    // events
    $in.addEventListener('input', updateInStats);
    document.addEventListener('keydown', (e)=>{ if((e.ctrlKey||e.metaKey) && e.key==='Enter'){ e.preventDefault(); run(); }});
    document.addEventListener('change',(e)=>{ const t=e.target; if(t && t.name==='mode'){ syncModeUI(); save(); } if(t && t.id==='byteMode'){ document.getElementById('byteExactSideWrap').style.display = ($byteMode.value==='exact') ? '' : 'none'; save(); } });
    document.querySelectorAll('input[name="mode"]').forEach(r=>{ r.addEventListener('change', ()=>{ syncModeUI(); save(); }); });

    document.getElementById('runBtn').addEventListener('click', run);

    document.getElementById('resetBtn').addEventListener('click', ()=>{ $in.value=''; $out.value=''; updateInStats(); updateOutStats(); try{localStorage.removeItem('tag30_opts_en');}catch(e){} $in.focus(); });

    document.getElementById('copyBtn').addEventListener('click', async ()=>{ if(!$out.value) return; try{ await navigator.clipboard.writeText($out.value); alert('Copied'); }catch(e){}; window.dataLayer=window.dataLayer||[]; window.dataLayer.push({event:'copy_click', tool:'tag30_en'}); });

    document.getElementById('downloadBtn').addEventListener('click', ()=>{
      const blob = new Blob([$out.value||''], {type:'text/plain;charset=utf-8'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'tag30-result.txt';
      document.body.appendChild(a); a.click(); a.remove();
      window.dataLayer=window.dataLayer||[]; window.dataLayer.push({event:'download_click', tool:'tag30_en'});
    });

    // init
    updateInStats(); updateOutStats(); load(); syncModeUI();

    document.getElementById('cookiePrefs')?.addEventListener('click',function(e){ e.preventDefault(); alert('Connect your CMP for a cookie preference dialog.'); });

    // track
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push({event:'tool_use', tool:'tag30_en'});
  </script>

  <!-- JSON-LD: FAQ -->
  <script type="application/ld+json">
  {"@context":"https://schema.org","@type":"FAQPage","mainEntity":[
    {"@type":"Question","name":"What’s the difference between line and byte intervals?","acceptedAnswer":{"@type":"Answer","text":"Line mode counts lines (e.g., every 30 lines). Byte mode counts UTF‑8 bytes (e.g., every 1024 bytes)."}},
    {"@type":"Question","name":"What does Friendly vs Exact mean in byte mode?","acceptedAnswer":{"@type":"Answer","text":"Friendly snaps to the start of the next line; Exact inserts at the exact byte boundary without splitting multibyte characters."}},
    {"@type":"Question","name":"How does ‘Insert tag at beginning’ work?","acceptedAnswer":{"@type":"Answer","text":"When enabled, it prepends the first tag at byte 0 / line 1, then continues at your chosen interval. With avoid-duplicates, it skips if the same tag is already present at the start."}},
    {"@type":"Question","name":"What is Inline insert (no line break)?","acceptedAnswer":{"@type":"Answer","text":"It appends the tag directly to the current line instead of creating a new line. Include spaces in your template if needed."}},
    {"@type":"Question","name":"What does ‘Add line break after tag’ do?","acceptedAnswer":{"@type":"Answer","text":"It forces a newline immediately after each inserted tag."}},
    {"@type":"Question","name":"What does the {TAG} placeholder mean?","acceptedAnswer":{"@type":"Answer","text":"{TAG} is replaced by your Tag 1/2/3 values in rotation. Example: template --{TAG}-- with Tag 1 = [A] becomes --[A]--."}},
    {"@type":"Question","name":"What is ‘Skip first lines/bytes’ for?","acceptedAnswer":{"@type":"Answer","text":"It lets you ignore headers/front matter and start tagging after the first N lines/bytes."}},
    {"@type":"Question","name":"Avoid duplicates and Trim options","acceptedAnswer":{"@type":"Answer","text":"Avoid duplicates skips if the same tag already exists at that point; Trim removes leading/trailing whitespace on the inserted tag line."}},
    {"@type":"Question","name":"Why normalize line endings (LF/CRLF)?","acceptedAnswer":{"@type":"Answer","text":"Different operating systems use different line breaks. Normalization prevents formatting issues across platforms."}},
    {"@type":"Question","name":"How do the 3 tags rotate?","acceptedAnswer":{"@type":"Answer","text":"They cycle Tag 1 → Tag 2 → Tag 3 → Tag 1… Empty tag fields are skipped."}},
    {"@type":"Question","name":"Are settings saved and restored?","acceptedAnswer":{"@type":"Answer","text":"Yes. We save to localStorage and restore on reload. Use Reset to clear."}},
    {"@type":"Question","name":"Is it safe with multibyte UTF‑8 characters?","acceptedAnswer":{"@type":"Answer","text":"Yes, Exact mode only inserts on UTF‑8 code point boundaries; characters are never split."}}
  ]}
  </script>
</body>
</html>