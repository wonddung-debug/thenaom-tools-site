<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>문자를 음성으로 — 역할 낭독 도구 (한국어)</title>
  <meta name="description" content="BYO Google TTS. 역할 대화/일반/세밀 조절. 자동 저장 옵션, 언어별 보이스 미리듣기, 긴 글 자동 나눔. 사이트 공통 UI/테마 통일." />
  <meta name="robots" content="index,follow" />
  <link rel="canonical" href="/tools/tts-dialog.html" />
  <link rel="alternate" hreflang="ko" href="/tools/tts-dialog.html" />
  <link rel="alternate" hreflang="en" href="/en/tools/tts-dialog.html" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.png" />
  <meta property="og:title" content="문자를 음성으로 — 역할 낭독 도구 (한국어)" />
  <meta property="og:description" content="Google Cloud TTS로 내 API키로 합성. 역할 대화/일반/세밀 조절, 긴 글 자동 나눔, 언어별 보이스 샘플." />
  <meta property="og:image" content="/assets/og-tool-tts-dialog.png" />
  <meta property="og:url" content="/tools/tts-dialog.html" />
  <meta property="og:type" content="website" />
  <meta property="og:locale" content="ko_KR" />

  <!-- Theme bootstrap (사이트 공통) -->
  <script>
    (function(){
      try{
        const saved=localStorage.getItem('theme');
        if(saved==='light'||saved==='dark'){
          document.documentElement.setAttribute('data-theme',saved);
          document.documentElement.setAttribute('data-user-theme','1');
        }else{
          const prefersDark=window.matchMedia('(prefers-color-scheme: dark)').matches;
          document.documentElement.setAttribute('data-theme',prefersDark?'dark':'light');
        }
      }catch(e){}
    })();
  </script>

  <!-- GTM (사이트 공통) -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-N2BBPNCC');</script>

  <!-- AdSense (사이트 공통) -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3006330103681332" crossorigin="anonymous"></script>

  <!-- 공통 스타일 토큰 (사이트 공통 버튼/레이아웃과 통일) -->
  <style>
    :root{ --bg:#ffffff; --text:#0b1220; --muted:#475569; --border:#e5e7eb; --card:#ffffff; --accent:#2563eb; --btn-text:#ffffff; --shadow:0 6px 18px rgba(0,0,0,.06); --focus: color-mix(in srgb, var(--accent) 35%, transparent); --input:#0b1220; --input-bg:var(--card); --hero-tint:#eff3ff; --hero-grid:#e8ecf6; --hero-ring:#cfe1ff }
    [data-theme="dark"]{ --bg:#0b1220; --text:#f1f5f9; --muted:#cbd5e1; --border:#334155; --card:#111827; --accent:#60a5fa; --btn-text:#0b1220; --shadow:0 8px 22px rgba(0,0,0,.55); --focus: color-mix(in srgb, var(--accent) 45%, transparent); --input:#e5e7eb; --input-bg:#0f172a; --hero-tint:#0f172a; --hero-grid:#162036; --hero-ring:#1f3b76 }
    html,body{background:var(--bg)!important}
    body{color:var(--text)!important;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,Arial,sans-serif}
    a{color:var(--accent);text-decoration:none}
    .container{max-width:1200px;margin:0 auto;padding:0 16px}

    /* Header 공통 */
    header.site{position:sticky;top:0;z-index:100;background:var(--bg)!important;border-bottom:1px solid var(--border)}
    .brand{color:var(--text)!important;font-weight:800;text-decoration:none}
    header.site nav{display:flex;align-items:center;gap:12px}
    .lang-switch,.theme-toggle,.btn{padding:.5rem .72rem;border:1px solid var(--border);border-radius:.7rem;background:linear-gradient(180deg,color-mix(in srgb,var(--card)96%,transparent),var(--card));cursor:pointer;color:var(--text)!important;box-shadow:var(--shadow);transition:transform .06s,box-shadow .18s,border-color .18s,background .18s}
    .lang-switch:hover,.theme-toggle:hover,.theme-toggle:focus-visible,.btn:hover{color:var(--accent)!important;border-color:var(--accent)!important;box-shadow:0 0 0 3px var(--focus), var(--shadow)}
    .theme-toggle:active,.btn:active{transform:translateY(1px)}
    .theme-toggle[aria-pressed="true"], .btn-primary{background:linear-gradient(180deg,color-mix(in srgb,var(--accent)22%,var(--card)),var(--accent));border-color:var(--accent)!important;color:var(--btn-text)!important}
    .btn-secondary{background:linear-gradient(180deg, color-mix(in srgb, var(--card) 95%, transparent), var(--card))}
    .btn-danger{background:linear-gradient(180deg,color-mix(in srgb,#ef4444 20%,var(--card)),#ef4444);border-color:#ef4444;color:#fff}

    /* Hero 공통 */
    .hero{position:relative;overflow:hidden;padding:28px 0 18px;text-align:start;isolation:isolate}
    .hero::before{content:"";position:absolute;inset:0;background:radial-gradient(900px 360px at 50% -15%, var(--hero-ring), transparent 65%),linear-gradient(180deg, color-mix(in srgb, var(--hero-tint) 88%, transparent), transparent 60%);z-index:-2}
    .hero::after{content:"";position:absolute;inset:0;background:linear-gradient(to right, color-mix(in srgb,var(--hero-grid) 35%, transparent) 1px, transparent 1px) 0 0/28px 28px,linear-gradient(to bottom, color-mix(in srgb,var(--hero-grid) 35%, transparent) 1px, transparent 1px) 0 0/28px 28px;opacity:.5;z-index:-1}
    .hero h1{margin:0;font-size:clamp(1.6rem,3.4vw,2.2rem)} .hero p{margin:.4rem 0 0;color:var(--muted);max-width:900px}
    .crumb{margin:10px 0 0;font-size:.95rem}.crumb a{color:var(--muted)} .hl{background:color-mix(in srgb, var(--accent) 14%, transparent);padding:0 4px;border-radius:6px}

    /* Panels 공통 */
    main .section{margin:12px 0}
    .ad-space{margin:8px 0}
    .panel{border:1px solid var(--border);border-radius:12px;background:linear-gradient(180deg, color-mix(in srgb, var(--card) 95%, transparent), var(--card));box-shadow:var(--shadow);padding:12px}
    .panel h2{margin:.1rem 0 .6rem;font-size:1.06rem}
    .panel h3{margin:1rem 0 .6rem;font-size:1rem}
    .row{display:grid;grid-template-columns:1fr;gap:12px}
    @media(min-width:980px){.row{grid-template-columns:1fr 1fr}}
    .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .small{font-size:.92rem;color:var(--muted)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}

    /* Inputs */
    textarea.input{width:100%;min-height:400px;padding:12px;border-radius:10px;border:1px solid var(--border);background:var(--input-bg);color:var(--input);font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.98rem;line-height:1.45;resize:vertical;white-space:pre-wrap}
    textarea.output{width:100%;min-height:220px;padding:12px;border-radius:10px;border:1px solid var(--border);background:var(--card);color:var(--text);font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.98rem;line-height:1.45;resize:vertical}
    select,input[type=text],input[type=password],input[type=number]{width:100%;padding:.6rem .72rem;border:1px solid var(--border);border-radius:.7rem;background:var(--input-bg);color:var(--input)}

    /* Tables & lists */
    .list{max-height:320px;overflow:auto;border:1px dashed var(--border);border-radius:10px}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid var(--border);padding:6px 8px;text-align:left}

    .pill{display:inline-block;padding:2px 8px;border:1px solid var(--border);border-radius:999px;font-size:12px;color:var(--muted)}
    .counter{display:flex;gap:12px;flex-wrap:wrap;color:var(--muted);font-size:.92rem;margin-top:6px}
  
    /* 새로운 메인 레이아웃 - 좌우 분할 */
    .main-layout{display:grid;grid-template-columns:1fr;gap:16px}
    @media(min-width:768px){.main-layout{grid-template-columns:2fr 1fr}}
    
    .left-section{display:flex;flex-direction:column;gap:12px}
    .right-section{display:flex;flex-direction:column;gap:12px}
    
    .role-table-container{overflow-x:auto}
    .role-table{min-width:800px;width:100%}
    
    .options-grid{display:grid;grid-template-columns:1fr;gap:12px}
    @media(min-width:600px){.options-grid{grid-template-columns:1fr 1fr}}
    
    .voice-options{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .voice-options label{min-width:80px;flex-shrink:0;font-size:0.9rem}
    .voice-options select{min-width:200px;flex:1}
    
    .chunk-options{margin-top:10px;padding:10px;border:1px solid var(--border);border-radius:8px;background:color-mix(in srgb,var(--card) 95%,transparent)}
    
    /* 진행 상태 바 */
    .progress-bar{height:4px;background:var(--border);border-radius:2px;overflow:hidden;margin:8px 0}
    .progress-fill{height:100%;background:var(--accent);transition:width 0.3s ease}
    
    /* 에러 메시지 스타일 */
    .error-msg{background:color-mix(in srgb,#ef4444 15%,transparent);border:1px solid #ef4444;border-radius:8px;padding:10px;margin:10px 0;color:var(--text)}
    .warning-msg{background:color-mix(in srgb,#f59e0b 15%,transparent);border:1px solid #f59e0b;border-radius:8px;padding:10px;margin:10px 0;color:var(--text)}
    
    /* 슬라이더 스타일 */
    .slider-container{display:flex;align-items:center;gap:8px;margin:8px 0}
    .slider{flex:1;height:6px;border-radius:3px;background:var(--border);appearance:none;outline:none}
    .slider::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);cursor:pointer}
    .slider::-moz-range-thumb{width:18px;height:18px;border-radius:50%;background:var(--accent);cursor:pointer;border:none}
    .slider-value{min-width:60px;text-align:center;font-family:monospace;font-size:0.9rem}
    
    /* 목소리 정보 스타일 */
    .voice-info{font-size:0.85rem;color:var(--muted);margin-top:2px}
    .voice-tag{display:inline-block;padding:1px 6px;margin:0 2px;border-radius:4px;font-size:0.75rem;font-weight:500}
    .voice-tag.female{background:color-mix(in srgb,#ec4899 20%,transparent);color:#be185d}
    .voice-tag.male{background:color-mix(in srgb,#3b82f6 20%,transparent);color:#1d4ed8}
    .voice-tag.neutral{background:color-mix(in srgb,#6b7280 20%,transparent);color:#374151}
    .voice-tag.premium{background:color-mix(in srgb,#f59e0b 20%,transparent);color:#d97706}
    .voice-tag.standard{background:color-mix(in srgb,#10b981 20%,transparent);color:#047857}
    .voice-tag.latest{background:color-mix(in srgb,#8b5cf6 20%,transparent);color:#7c3aed}
    
    /* 설정 그룹 스타일 */
    .setting-group{margin-bottom:16px}
    .setting-group label{display:block;margin-bottom:4px;font-size:0.9rem;font-weight:500}
    .setting-group select{width:100%}
    
    /* 반응형 개선 */
    @media(max-width:767px){
      .voice-options{flex-direction:column;align-items:stretch}
      .voice-options label{min-width:auto}
      .voice-options select{min-width:auto}
    }
  </style>
</head>
<body>
  <!-- GTM (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-N2BBPNCC" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

  <!-- Header (사이트 공통) -->
  <header class="site">
    <div class="container" style="display:flex;justify-content:space-between;align-items:center">
      <a href="/" class="brand">Thenaom Tools</a>
      <nav aria-label="보조 탐색">
        <a class="lang-switch" href="/en/tools/tts-dialog.html" hreflang="en">English</a>
        <button id="themeToggle" class="theme-toggle" aria-pressed="false" title="테마 전환"><span class="icon">🌞</span><span class="label">라이트</span></button>
      </nav>
    </div>
  </header>

  <!-- Hero -->
  <section class="hero">
    <div class="container">
      <div class="crumb"><a href="/">홈</a> &nbsp;>&nbsp; <a href="/audio/">오디오</a> &nbsp;>&nbsp; 문자를 음성으로</div>
      <h1>문자를 음성으로 — <span class="hl">역할 낭독 도구</span> (한국어)</h1>
      <p>내 Google Cloud TTS <span class="hl">API 키</span>로, 대화를 자연스럽게 합성합니다. <b>역할 대화/일반/세밀 조절</b>을 지원하고, <b>긴 글 자동 나눔</b>으로 안전하게 이어붙입니다.</p>
    </div>
  </section>

  <main class="container" id="main">
    <!-- 상단 광고 -->
    <div class="ad-space"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-3006330103681332" data-ad-slot="6703005412" data-ad-format="auto" data-full-width-responsive="true"></ins></div>
    <script>(adsbygoogle=window.adsbygoogle||[]).push({});</script>

    <!-- 미니 상태줄: API 저장 여부 -->
    <section class="section">
      <div class="panel" id="miniBar" style="display:flex;align-items:center;gap:10px;justify-content:space-between">
        <div class="controls">
          <span id="apiBadge" class="btn" style="pointer-events:none">API 입력 필요</span>
          <span class="small" id="apiMiniText">API 키를 저장해야 사용할 수 있어요</span>
        </div>
        <div class="controls small">
          <span>모드: <b id="modeMini">역할 대화</b></span>
        </div>
      </div>
    </section>

    <!-- 메인 컨텐츠 레이아웃 - 좌우 분할 -->
    <section class="section">
      <div class="main-layout">
        <!-- 왼쪽 섹션: 텍스트 입력 및 역할 관리 -->
        <div class="left-section">
          <!-- 모드 선택 -->
          <div class="panel">
            <h2>모드 선택</h2>
            <div class="controls" style="margin-bottom:8px">
              <div role="tablist" aria-label="모드" class="controls" id="modeChips">
                <button class="btn btn-secondary" data-val="plain" aria-pressed="false">일반</button>
                <button class="btn btn-primary" data-val="dialog" aria-pressed="true">역할 대화</button>
                <button class="btn btn-secondary" data-val="ssml" aria-pressed="false">세밀 조절(전문가용)</button>
              </div>
            </div>
            <div class="small" id="modeHint" style="color:var(--muted)">역할 대화: 줄 앞에 "이름: 내용" 또는 "[이름] 내용"</div>
          </div>

          <!-- 텍스트 입력 -->
          <div class="panel">
            <h2>텍스트 입력</h2>
            <textarea id="editor" class="input mono" placeholder="예: 할머니: 오늘은 여기까지 하자.&#10;소년: 아직 할 말이 있어요!"></textarea>
            <div class="counter" id="counter">0 글자 / 0 바이트</div>

            <!-- 긴 글 자동 나눔 옵션 -->
            <div class="chunk-options">
              <div class="controls">
                <label for="chunkTgl" class="small" style="min-width:160px">긴 글 자동 나눔</label>
                <button id="chunkTgl" class="btn btn-primary" aria-pressed="true">ON</button>
              </div>
              <div class="small" style="margin-top:6px">요청 1회당 <b>5,000바이트</b> 제한. <b>한글 기준 대략 1,600자</b>를 넘으면 <b>오류</b>가 날 수 있어요. 이 기능을 <b>켜두면</b> 길이를 자동으로 나누어서 이어붙입니다.</div>
            </div>
          </div>

          <!-- 역할 대화 전용 옵션 -->
          <div class="panel" id="dialogOptions" style="display:block">
            <h2>역할 대화 설정</h2>
            
            <!-- 대화 옵션 -->
            <div class="options-grid">
              <div class="setting-group">
                <label>말 바뀔 때 잠깐 쉬기</label>
                <select id="switchSelect">
                  <option value="0">0ms - 바로 이어서</option>
                  <option value="150" selected>150ms - 추천</option>
                  <option value="300">300ms - 여유롭게</option>
                  <option value="500">500ms - 충분히</option>
                </select>
                <div class="small" style="margin-top:4px;color:var(--muted)">말하는 사람이 바뀌는 지점에만 짧게 쉬어 더 자연스럽게 들립니다.</div>
              </div>

              <div class="setting-group">
                <label>줄마다 기본으로 되돌리기</label>
                <button id="lineResetTgl" class="btn btn-primary" aria-pressed="true">ON</button>
                <div class="small" style="margin-top:4px;color:var(--muted)">ON이면 <b>그 줄에 적힌 이름만</b> 해당 목소리로 읽고, 다음 줄은 자동으로 <b>기본 목소리</b>로 돌아갑니다.</div>
              </div>
            </div>

            <!-- 역할 관리 도구 -->
            <div style="margin-top:16px">
              <div class="controls" style="justify-content:space-between;margin-bottom:8px">
                <h3 style="margin:0">이름 설정표</h3>
                <div class="controls">
                  <button id="detectBtn" class="btn btn-secondary small">이름 자동찾기</button>
                  <button id="addRoleBtn" class="btn btn-secondary small">이름 추가</button>
                  <button id="seniorAllBtn" class="btn btn-secondary small">모두 듣기 편하게</button>
                  <button id="resetRolesBtn" class="btn btn-danger small">초기화</button>
                </div>
              </div>

              <!-- 역할 테이블 -->
              <div class="role-table-container">
                <div class="list">
                  <table class="small role-table" id="roleTable">
                    <thead>
                      <tr>
                        <th>이름</th>
                        <th>목소리</th>
                        <th>▶</th>
                        <th>속도(%)</th>
                        <th>톤(semi)</th>
                        <th>볼륨(dB)</th>
                        <th>듣기 편함</th>
                        <th>언어</th>
                      </tr>
                    </thead>
                    <tbody></tbody>
                  </table>
                </div>
              </div>
              <div class="small" id="roleCount" style="margin-top:6px;color:var(--muted)"></div>

              <!-- 선택 도구 -->
              <div class="controls small" style="margin-top:8px">
                <button id="aliasBtn" class="btn btn-secondary">선택한 문장에 이름 붙이기</button>
                <button id="altBtn" class="btn btn-secondary">여러 줄에 A/B 번갈아 붙이기</button>
              </div>
            </div>
          </div>

          <!-- SSML 치트시트 -->
          <div id="ssmlCheat" class="panel" style="display:none">
            <h3>SSML 명령(전체)</h3>
            <ul class="small">
              <li><code class="mono">&lt;speak&gt;...&lt;/speak&gt;</code> — 루트 컨테이너 (필수)</li>
              <li><code class="mono">&lt;p&gt;</code>, <code class="mono">&lt;s&gt;</code> — 문단/문장 경계</li>
              <li><code class="mono">&lt;break time="300ms"/&gt;</code> — 쉬기 (예: 150ms, 300ms)</li>
              <li><code class="mono">&lt;emphasis level="moderate|strong|reduced"&gt;강조&lt;/emphasis&gt;</code></li>
              <li><code class="mono">&lt;prosody rate="0.95" pitch="-2st" volume="+2dB"&gt;텍스트&lt;/prosody&gt;</code></li>
              <li><code class="mono">&lt;say-as interpret-as="characters|digits|cardinal|ordinal|date|time|telephone"&gt;값&lt;/say-as&gt;</code></li>
              <li><code class="mono">&lt;sub alias="대체 발음"&gt;원문&lt;/sub&gt;</code> — 발음 바꾸기</li>
              <li><code class="mono">&lt;mark name="S1"/&gt;</code> — 타임포인트(마커)</li>
            </ul>
          </div>
        </div>

        <!-- 오른쪽 섹션: 음성 설정 및 실행 -->
        <div class="right-section">
          <!-- 기본 음성 설정 -->
          <div class="panel">
            <h2>기본 음성 설정</h2>
            <div class="setting-group">
              <label>언어</label>
              <select id="baseLangSel"></select>
            </div>
            <div class="setting-group">
              <label>목소리</label>
              <select id="baseVoiceSel"></select>
              <button id="basePreviewBtn" class="btn btn-secondary small" style="margin-top:6px">▶ 미리듣기</button>
            </div>
            <div id="baseVoiceInfo" class="voice-info"></div>
          </div>

          <!-- 일반 모드 음성 조절 -->
          <div class="panel" id="plainVoiceControls" style="display:none">
            <h2>음성 조절</h2>
            
            <div class="setting-group">
              <label>말하기 속도</label>
              <div class="slider-container">
                <input type="range" id="plainSpeedSlider" class="slider" min="25" max="400" value="100" step="5">
                <span class="slider-value" id="plainSpeedValue">100%</span>
              </div>
              <div class="controls" style="margin-top:4px">
                <button class="btn btn-secondary small" onclick="setPlainSpeed(75)">느리게</button>
                <button class="btn btn-secondary small" onclick="setPlainSpeed(100)">보통</button>
                <button class="btn btn-secondary small" onclick="setPlainSpeed(150)">빠르게</button>
              </div>
            </div>

            <div class="setting-group">
              <label>음높이 (반음)</label>
              <div class="slider-container">
                <input type="range" id="plainPitchSlider" class="slider" min="-20" max="20" value="0" step="1">
                <span class="slider-value" id="plainPitchValue">0</span>
              </div>
              <div class="controls" style="margin-top:4px">
                <button class="btn btn-secondary small" onclick="setPlainPitch(-5)">낮게</button>
                <button class="btn btn-secondary small" onclick="setPlainPitch(0)">보통</button>
                <button class="btn btn-secondary small" onclick="setPlainPitch(5)">높게</button>
              </div>
            </div>

            <div class="setting-group">
              <label>볼륨 (dB)</label>
              <div class="slider-container">
                <input type="range" id="plainVolumeSlider" class="slider" min="-10" max="16" value="0" step="0.5">
                <span class="slider-value" id="plainVolumeValue">0dB</span>
              </div>
              <div class="controls" style="margin-top:4px">
                <button class="btn btn-secondary small" onclick="setPlainVolume(-6)">작게</button>
                <button class="btn btn-secondary small" onclick="setPlainVolume(0)">보통</button>
                <button class="btn btn-secondary small" onclick="setPlainVolume(6)">크게</button>
              </div>
            </div>
          </div>

          <!-- 오디오 효과 프로필 -->
          <div class="panel">
            <h2>오디오 효과</h2>
            <div class="setting-group">
              <label>재생 환경 최적화</label>
              <select id="effectsProfileSel">
                <option value="">없음 (기본)</option>
                <option value="headphone-class-device">헤드폰용</option>
                <option value="handset-class-device">휴대폰 스피커용</option>
                <option value="small-bluetooth-speaker-class-device">블루투스 스피커 (소형)</option>
                <option value="medium-bluetooth-speaker-class-device">블루투스 스피커 (중형)</option>
                <option value="large-home-entertainment-class-device">홈 오디오 시스템용</option>
                <option value="large-automotive-class-device">자동차용</option>
                <option value="telephony-class-application">전화통화용</option>
                <option value="wearable-class-device">웨어러블 기기용</option>
              </select>
              <div class="small" style="margin-top:6px;color:var(--muted)">선택한 재생 환경에 맞게 음질을 최적화합니다.</div>
            </div>
          </div>

          <!-- 출력 설정 -->
          <div class="panel">
            <h2>출력 설정</h2>
            
            <div class="setting-group">
              <label>오디오 형식</label>
              <select id="encodingSelect">
                <option value="MP3">MP3 (일반용, 작은 파일)</option>
                <option value="LINEAR16">WAV (고품질, 큰 파일)</option>
                <option value="OGG_OPUS">OGG (압축 효율적)</option>
              </select>
            </div>

            <div class="setting-group">
              <label>샘플레이트</label>
              <select id="sampleRateSelect">
                <option value="24000">24kHz (기본)</option>
                <option value="44100">44.1kHz (CD 품질)</option>
                <option value="48000">48kHz (고품질)</option>
              </select>
            </div>

            <div class="setting-group">
              <label>문장 사이 쉬기</label>
              <select id="sentenceBreakSelect">
                <option value="0">0ms - 연속으로</option>
                <option value="150">150ms - 자연스럽게</option>
                <option value="300">300ms - 또박또박</option>
                <option value="500">500ms - 천천히</option>
                <option value="1000">1000ms - 여유롭게</option>
              </select>
            </div>

            <div class="setting-group">
              <label>기타 설정</label>
              <div class="controls" style="flex-direction:column;align-items:stretch;gap:6px">
                <div class="controls">
                  <label style="min-width:120px">전체 음성 크기 균등화</label>
                  <button id="normTgl" class="btn btn-primary" aria-pressed="true">ON</button>
                </div>
                <div class="controls">
                  <label style="min-width:120px">재시도 횟수</label>
                  <select id="retrySelect" style="width:100px">
                    <option value="0">0회</option>
                    <option value="1">1회</option>
                    <option value="3" selected>3회</option>
                    <option value="5">5회</option>
                  </select>
                </div>
              </div>
            </div>
          </div>

          <!-- 음성 만들기 -->
          <div class="panel">
            <h2>음성 생성</h2>
            <div class="controls" style="flex-direction:column;gap:8px">
              <button id="makeBtn" class="btn btn-primary" style="width:100%"><span id="makeLabel">음성 만들기</span></button>
              <button id="cancelBtn" class="btn btn-danger" style="display:none;width:100%">취소</button>
              <span id="status" class="small"></span>
            </div>
            
            <!-- 진행 상태 바 -->
            <div class="progress-bar" id="progressBar" style="display:none">
              <div class="progress-fill" id="progressFill" style="width:0%"></div>
            </div>
            
            <!-- 에러 메시지 영역 -->
            <div id="errorArea"></div>
            
            <audio id="player" controls style="margin-top:8px;width:100%"></audio>
            <div class="controls small" style="margin-top:6px;flex-direction:column;gap:6px">
              <a id="download" class="btn btn-secondary small" href="#" style="display:none;width:100%">다운로드</a>
              <span class="small" id="outInfo" style="text-align:center"></span>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- 언어 샘플 & API 설정 -->
    <section class="section">
      <div class="row">
        <!-- 언어 샘플 -->
        <div class="panel">
          <h2>언어 샘플</h2>
          <div class="setting-group">
            <label>언어 선택</label>
            <select id="sampleLang"></select>
          </div>
          <div class="setting-group">
            <label>샘플 문장</label>
            <input id="sampleText" type="text" class="mono" value="안녕하세요. 이것은 샘플 문장입니다." />
          </div>
          <div class="small" style="margin:8px 0;color:var(--muted)">언어를 고르면 아래에 그 언어의 목소리들이 쭉 나옵니다. 각 행의 ▶로 들어보고, 버튼으로 이름 설정표에 바로 지정할 수 있어요.</div>
          <div class="list">
            <table class="small" id="voiceTable">
              <thead><tr><th>이름</th><th>정보</th><th>▶</th><th>기본 이름에 쓰기</th><th>선택 이름에 쓰기</th></tr></thead>
              <tbody></tbody>
            </table>
          </div>
        </div>

        <!-- API 설정 -->
        <div class="panel">
          <h2>API 설정</h2>
          <div class="setting-group">
            <label for="apiKey">Google TTS API 키</label>
            <div class="controls" style="flex-direction:column;gap:6px">
              <input id="apiKey" type="password" placeholder="AIza... (당신의 키)" autocomplete="off" />
              <div class="controls">
                <button id="showKeyBtn" class="btn btn-secondary">표시</button>
                <button id="saveKeyBtn" class="btn btn-primary">저장</button>
                <button id="clearKeyBtn" class="btn btn-danger">삭제</button>
                <button id="testBtn" class="btn btn-secondary">테스트</button>
              </div>
            </div>
          </div>
          <p class="small" style="margin-top:6px;color:var(--muted)">키는 이 브라우저에만 저장됩니다. GCP 콘솔에서 Text-to-Speech API 활성화 → API 제한에서 TTS만 허용 → 내 도메인을 HTTP referrer로 추가하는 것을 권장합니다.</p>
        </div>
      </div>
    </section>

    <!-- 설명서 -->
    <section class="section">
      <div class="panel">
        <h2>설명서</h2>
        <div class="small" style="line-height:1.7">
          <h3>모드</h3>
          <ul>
            <li><b>일반</b>: 한 사람이 쭉 읽습니다. 음성 조절과 오디오 효과를 사용할 수 있습니다.</li>
            <li><b>역할 대화</b>: 줄 앞에 <code class="mono">이름: 내용</code> 또는 <code class="mono">[이름] 내용</code> 형태로 쓰면, 이름별 목소리를 적용합니다.</li>
            <li><b>세밀 조절(전문가용)</b>: SSML을 직접 씁니다. 아래 명령 참조.</li>
          </ul>

          <h3>새로운 기능</h3>
          <ul>
            <li><b>개선된 UI</b>: 텍스트 입력을 왼쪽에 넓게, 설정을 오른쪽에 깔끔하게 배치했습니다.</li>
            <li><b>정확한 목소리 정보</b>: 성별, 모델 유형, 품질 등급을 정확하게 표시합니다.</li>
            <li><b>드롭다운 설정</b>: 모든 출력 설정을 사용하기 쉬운 드롭다운으로 변경했습니다.</li>
            <li><b>음성 조절</b>: 일반 모드에서 속도, 음높이, 볼륨을 세밀하게 조절할 수 있습니다.</li>
            <li><b>오디오 효과</b>: 헤드폰, 스피커, 자동차 등 재생 환경에 맞게 음질을 최적화합니다.</li>
          </ul>

          <h3>긴 글 자동 나눔</h3>
          <p>Google TTS는 <b>요청당 5,000바이트</b> 제한이 있습니다. <b>한글만 기준 약 1,600자</b>를 넘기면 오류/느김이 생길 수 있어 <b>자동 나눔 ON</b>을 권장합니다.</p>
        </div>
      </div>
    </section>

    <!-- 하단 광고 & 푸터 -->
    <div class="ad-space"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-3006330103681332" data-ad-slot="3909128617" data-ad-format="auto" data-full-width-responsive="true"></ins></div>
    <script>(adsbygoogle=window.adsbygoogle||[]).push({});</script>

    <footer class="site">
      <div class="container footer-row">
        <div class="footer-links">
          <a href="/text/">텍스트 정리</a>
          <a href="/utility/">업무 유틸</a>
          <a href="/audio/">오디오</a>
          <a href="/privacy/">개인정보 처리방침</a>
        </div>
        <div class="small">© 2025 Thenaom</div>
      </div>
    </footer>
  </main>

  <!-- ====== 스크립트 ====== -->
  <script>
    // Theme toggle (공통)
    (function(){
      const btn=document.getElementById('themeToggle'); 
      if(!btn) return;
      function sync(){ 
        const mode=document.documentElement.getAttribute('data-theme')||'light'; 
        btn.setAttribute('aria-pressed', mode==='dark'); 
        btn.querySelector('.icon').textContent = mode==='dark'?'🌙':'🌞'; 
        btn.querySelector('.label').textContent = mode==='dark'?'다크':'라이트'; 
      }
      btn.addEventListener('click', function(){ 
        const cur=document.documentElement.getAttribute('data-theme')||'light'; 
        const next=(cur==='dark'?'light':'dark'); 
        document.documentElement.setAttribute('data-theme', next); 
        localStorage.setItem('theme', next); 
        sync();
      });
      sync();
    })();

    // ===== 상태/저장 키 =====
    const LS = {
      KEY: 'gcpKey', 
      ROLES: 'rolesV8', 
      MODE: 'modeV8', 
      OPTS: 'optsV8', 
      SAMPLE: 'sampleLangV8'
    };
    
    const $ = id => document.getElementById(id);
    const bCount = s => new TextEncoder().encode(s||'').length;
    const on = (el, ev, fn) => el && el.addEventListener(ev, fn);
    const sleep = ms => new Promise(r => setTimeout(r, ms));
    
    // 전역 변수들
    let cancelRequested = false;
    let activeAudioUrls = [];

    // 미니 API 배지
    function updateApiBadge(){
      const has = !!localStorage.getItem(LS.KEY);
      const badge = $('apiBadge'); 
      const txt = $('apiMiniText');
      badge.classList.toggle('btn-primary', has);
      badge.classList.toggle('btn-danger', !has);
      badge.textContent = has ? 'API 저장됨' : 'API 입력 필요';
      txt.textContent = has ? '이 브라우저에 API 키가 저장되어 있습니다' : 'API 키를 저장해야 사용할 수 있어요';
    }

    // 카운터
    const editor = $('editor');
    function updateCounter(){ 
      $('counter').textContent = editor.value.length + " 글자 / " + bCount(editor.value) + " 바이트"; 
    }
    on(editor, 'input', updateCounter);

    // 모드 설정
    let mode = localStorage.getItem(LS.MODE) || 'dialog';
    function setMode(m){ 
      mode = m; 
      localStorage.setItem(LS.MODE, m); 
      $('modeMini').textContent = (m === 'plain' ? '일반' : (m === 'dialog' ? '역할 대화' : '세밀 조절'));
      
      // 모드 버튼 상태 변경
      document.querySelectorAll('#modeChips .btn').forEach(b => { 
        const on = (b.dataset.val === m); 
        b.classList.toggle('btn-primary', on); 
        b.classList.toggle('btn-secondary', !on); 
        b.setAttribute('aria-pressed', on); 
      });
      
      // 힌트 텍스트 변경
      if (m === 'plain') {
        $('modeHint').textContent = '일반: 한 사람이 쭉 읽습니다. 오른쪽에서 음성을 세밀하게 조절할 수 있어요.';
        editor.placeholder = '예: 오늘은 여기까지 하자.';
      } else if (m === 'dialog') {
        $('modeHint').textContent = '역할 대화: 줄 앞에 "이름: 내용" 또는 "[이름] 내용"';
        editor.placeholder = '예: 할머니: 오늘은 여기까지 하자.\n소년: 아직 할 말이 있어요!';
      } else {
        $('modeHint').textContent = '세밀 조절: <speak>…</speak> 에 SSML 명령 사용';
        editor.placeholder = '<speak>안녕하세요. <break time="300ms"/> 안내를 시작합니다.</speak>';
      }
      
      // 패널 표시/숨김
      const dialogOptions = $('dialogOptions');
      const ssmlCheat = $('ssmlCheat');
      const plainVoiceControls = $('plainVoiceControls');
      
      if (dialogOptions) {
        dialogOptions.style.display = (m === 'dialog') ? 'block' : 'none';
      }
      if (ssmlCheat) {
        ssmlCheat.style.display = (m === 'ssml') ? 'block' : 'none';
      }
      if (plainVoiceControls) {
        plainVoiceControls.style.display = (m === 'plain') ? 'block' : 'none';
      }
    }

    // 모드 칩 이벤트
    document.querySelectorAll('#modeChips .btn').forEach(b => 
      on(b, 'click', () => setMode(b.dataset.val))
    );

    // 일반 모드 음성 조절 함수들
    function setPlainSpeed(value) {
      $('plainSpeedSlider').value = value;
      $('plainSpeedValue').textContent = value + '%';
      autosave();
    }

    function setPlainPitch(value) {
      $('plainPitchSlider').value = value;
      $('plainPitchValue').textContent = value;
      autosave();
    }

    function setPlainVolume(value) {
      $('plainVolumeSlider').value = value;
      $('plainVolumeValue').textContent = value + 'dB';
      autosave();
    }

    // 슬라이더 이벤트
    on($('plainSpeedSlider'), 'input', (e) => {
      $('plainSpeedValue').textContent = e.target.value + '%';
      autosave();
    });

    on($('plainPitchSlider'), 'input', (e) => {
      $('plainPitchValue').textContent = e.target.value;
      autosave();
    });

    on($('plainVolumeSlider'), 'input', (e) => {
      $('plainVolumeValue').textContent = e.target.value + 'dB';
      autosave();
    });

    // 자동 저장 옵션
    function loadOpts(){ 
      try { 
        return JSON.parse(localStorage.getItem(LS.OPTS) || '{}'); 
      } catch { 
        return {}; 
      } 
    }
    
    function autosave(){ 
      const data = {
        encoding: $('encodingSelect') ? $('encodingSelect').value : 'MP3',
        sampleRate: $('sampleRateSelect') ? $('sampleRateSelect').value : '44100',
        sentenceBreak: $('sentenceBreakSelect') ? $('sentenceBreakSelect').value : '300',
        switchDelay: $('switchSelect') ? $('switchSelect').value : '150',
        norm: $('normTgl') ? $('normTgl').getAttribute('aria-pressed') === 'true' : true,
        chunk: $('chunkTgl') ? $('chunkTgl').getAttribute('aria-pressed') === 'true' : true,
        retry: $('retrySelect') ? $('retrySelect').value : '3',
        lineReset: $('lineResetTgl') ? $('lineResetTgl').getAttribute('aria-pressed') === 'true' : true,
        plainSpeed: $('plainSpeedSlider') ? $('plainSpeedSlider').value : '100',
        plainPitch: $('plainPitchSlider') ? $('plainPitchSlider').value : '0',
        plainVolume: $('plainVolumeSlider') ? $('plainVolumeSlider').value : '0',
        effectsProfile: $('effectsProfileSel') ? $('effectsProfileSel').value : ''
      }; 
      localStorage.setItem(LS.OPTS, JSON.stringify(data)); 
    }

    // 토글 공통
    function toggleBtn(btn){ 
      const on = btn.getAttribute('aria-pressed') === 'true'; 
      btn.setAttribute('aria-pressed', String(!on)); 
      btn.classList.toggle('btn-primary', !on); 
      btn.classList.toggle('btn-secondary', on); 
      btn.textContent = (!on) ? 'ON' : 'OFF'; 
      autosave(); 
    }

    // 드롭다운 이벤트들
    ['encodingSelect', 'sampleRateSelect', 'sentenceBreakSelect', 'switchSelect', 'retrySelect', 'effectsProfileSel'].forEach(id => {
      const el = $(id);
      if (el) on(el, 'change', autosave);
    });
    
    on($('normTgl'), 'click', e => toggleBtn(e.currentTarget));
    on($('chunkTgl'), 'click', e => toggleBtn(e.currentTarget));
    on($('lineResetTgl'), 'click', e => toggleBtn(e.currentTarget));

    // API 키
    const apiKey = $('apiKey');
    on($('showKeyBtn'), 'click', () => { 
      apiKey.type = (apiKey.type === 'password' ? 'text' : 'password'); 
      $('showKeyBtn').textContent = (apiKey.type === 'password' ? '표시' : '숨기기'); 
    });
    
    on($('saveKeyBtn'), 'click', () => { 
      const v = apiKey.value.trim(); 
      if (!v) return showError('API 키를 입력하세요'); 
      localStorage.setItem(LS.KEY, v); 
      updateApiBadge(); 
      showSuccess('API 키 저장됨'); 
      loadVoices().then(() => {
        renderVoiceList(); 
        renderBaseVoiceSelect();
      }); 
    });
    
    on($('clearKeyBtn'), 'click', () => { 
      localStorage.removeItem(LS.KEY); 
      updateApiBadge(); 
      showWarning('API 키 삭제됨'); 
    });
    
    on($('testBtn'), 'click', async () => { 
      try { 
        if (!localStorage.getItem(LS.KEY)) throw new Error('API 키가 없음'); 
        await loadVoices(); 
        showSuccess('정상: 목소리 목록을 불러왔습니다'); 
        renderVoiceList(); 
        renderBaseVoiceSelect();
      } catch (e) { 
        showError('실패: ' + parseError(e)); 
      } 
    });

    // 에러 메시지 표시 함수들
    function showError(msg) {
      const area = $('errorArea');
      if (area) {
        area.innerHTML = `<div class="error-msg">${msg}</div>`;
        setTimeout(() => area.innerHTML = '', 5000);
      } else {
        alert(msg);
      }
    }

    function showWarning(msg) {
      const area = $('errorArea');
      if (area) {
        area.innerHTML = `<div class="warning-msg">${msg}</div>`;
        setTimeout(() => area.innerHTML = '', 5000);
      } else {
        alert(msg);
      }
    }

    function showSuccess(msg) {
      alert(msg);
    }

    // 에러 파싱
    function parseError(e) {
      if (e.message) {
        if (e.message.includes('403')) return '권한 오류: API 키를 확인하거나 API 제한 설정을 확인하세요';
        if (e.message.includes('400')) return '잘못된 요청: 텍스트가 너무 길거나 형식이 잘못됨';
        if (e.message.includes('429')) return '요청 한도 초과: 잠시 후 다시 시도하세요';
        if (e.message.includes('500')) return 'Google 서버 오류: 잠시 후 다시 시도하세요';
        if (e.message.includes('does not support SSML')) return '이 음성은 SSML을 지원하지 않습니다';
        return e.message;
      }
      return String(e);
    }

    // 개선된 목소리 분석 함수
    function analyzeVoice(voice) {
      const name = voice.name.toLowerCase();
      
      // 실제 API 데이터 사용
      let gender = 'neutral';
      if (voice.ssmlGender === 'FEMALE') gender = 'female';
      else if (voice.ssmlGender === 'MALE') gender = 'male';
      else if (voice.ssmlGender === 'NEUTRAL') gender = 'neutral';
      
      // 모델 유형 및 품질 분석
      let modelType = 'Standard';
      let quality = 'standard';
      let isLatest = false;
      
      if (name.includes('neural2')) {
        modelType = 'Neural2';
        quality = 'premium';
        isLatest = true;
      } else if (name.includes('wavenet')) {
        modelType = 'WaveNet';
        quality = 'premium';
      } else if (name.includes('chirp3') || name.includes('chirp-hd')) {
        modelType = 'Chirp HD';
        quality = 'premium';
        isLatest = true;
      } else if (name.includes('studio')) {
        modelType = 'Studio';
        quality = 'premium';
        isLatest = true;
      } else if (name.includes('standard')) {
        modelType = 'Standard';
        quality = 'standard';
      }
      
      return { gender, modelType, quality, isLatest };
    }

    // 목소리 정보 표시
    function formatVoiceInfo(voice) {
      const info = analyzeVoice(voice);
      const genderText = info.gender === 'female' ? '여성' : (info.gender === 'male' ? '남성' : '중성');
      
      let tags = `<span class="voice-tag ${info.gender}">${genderText}</span>`;
      tags += `<span class="voice-tag ${info.quality}">${info.modelType}</span>`;
      if (info.isLatest) {
        tags += `<span class="voice-tag latest">최신</span>`;
      }
      
      return tags;
    }

    // 드롭다운용 목소리 옵션 텍스트
    function formatVoiceOption(voice) {
      const info = analyzeVoice(voice);
      const genderText = info.gender === 'female' ? '여성' : (info.gender === 'male' ? '남성' : '중성');
      const latestText = info.isLatest ? ', 최신' : '';
      return `${voice.name} (${genderText}, ${info.modelType}${latestText})`;
    }

    // 목소리 목록
    let VOICES = []; 
    let voiceIndex = {};
    
    async function loadVoices(){ 
      const key = localStorage.getItem(LS.KEY); 
      if (!key) return; 
      const u = new URL('https://texttospeech.googleapis.com/v1/voices'); 
      u.searchParams.set('key', key); 
      const r = await fetch(u); 
      const j = await r.json(); 
      if (!r.ok) throw new Error(j.error?.message || r.statusText); 
      VOICES = (j.voices || []).sort((a, b) => a.name > b.name ? 1 : -1); 
      voiceIndex = {}; 
      VOICES.forEach(v => voiceIndex[v.name] = v); 
    }

    // 이름(역할) 관리
    const roleBody = document.querySelector('#roleTable tbody');
    let roles = JSON.parse(localStorage.getItem(LS.ROLES) || '{}');
    
    function ensureBaseRole(){ 
      if (!roles._) { 
        roles._ = {voice: '', speed: '100', pitch: '0', vol: '0', lang: 'ko-KR', comfy: true}; 
      } 
    }
    
    function saveRoles(){ 
      localStorage.setItem(LS.ROLES, JSON.stringify(roles)); 
    }
    
    function roleRow(alias, data){ 
      const tr = document.createElement('tr');
      const langs = [...new Set(VOICES.flatMap(v => v.languageCodes || []))].sort();
      const langOpts = langs.map(c => `<option ${data.lang === c ? 'selected' : ''} value="${c}">${c}</option>`).join('');
      const voicesForLang = VOICES.filter(v => (v.languageCodes || []).includes(data.lang));
      const vOptions = `<option value="" ${!data.voice ? 'selected' : ''}>— 선택 —</option>` + 
        (voicesForLang.length ? voicesForLang : VOICES).map(v => 
          `<option ${data.voice === v.name ? 'selected' : ''} value="${v.name}">${formatVoiceOption(v)}</option>`
        ).join('');
      
      tr.innerHTML = `
        <td class="mono">${alias === '_' ? '기본' : alias}${!data.voice ? '<span style="background:#ef4444;color:#fff;border-radius:6px;padding:1px 6px;margin-left:6px;font-size:11px">목소리 선택</span>' : ''}</td>
        <td><select class="voiceSel">${vOptions}</select></td>
        <td><button class="btn btn-secondary small prevBtn">▶</button></td>
        <td>
          <div class="controls">
            <input class="speedNum" type="number" min="50" max="200" step="1" value="${data.speed}" style="width:90px" />
            <div class="controls">
              <button class="btn btn-secondary small speedC" data-val="80">느리게</button>
              <button class="btn btn-secondary small speedC" data-val="100">보통</button>
              <button class="btn btn-secondary small speedC" data-val="120">빠르게</button>
            </div>
          </div>
        </td>
        <td>
          <div class="controls">
            <input class="pitchNum" type="number" min="-12" max="12" step="1" value="${data.pitch}" style="width:90px" />
            <div class="controls">
              <button class="btn btn-secondary small pitchC" data-val="-2">낮게</button>
              <button class="btn btn-secondary small pitchC" data-val="0">보통</button>
              <button class="btn btn-secondary small pitchC" data-val="+2">높게</button>
            </div>
          </div>
        </td>
        <td>
          <div class="controls">
            <input class="volNum" type="number" min="-10" max="10" step="0.1" value="${data.vol}" style="width:90px" />
            <div class="controls">
              <button class="btn btn-secondary small volC" data-val="-2">작게</button>
              <button class="btn btn-secondary small volC" data-val="0">보통</button>
              <button class="btn btn-secondary small volC" data-val="+2">크게</button>
            </div>
          </div>
        </td>
        <td><button class="btn ${data.comfy ? 'btn-primary' : 'btn-secondary'} small comfy" aria-pressed="${data.comfy ? 'true' : 'false'}">${data.comfy ? 'ON' : 'OFF'}</button></td>
        <td><select class="langSel">${langOpts}</select></td>`;
      
      // 이벤트 핸들러
      tr.querySelector('.prevBtn').onclick = () => { 
        const name = tr.querySelector('.voiceSel').value; 
        if (!name) return showError('먼저 목소리를 선택하세요'); 
        previewVoice(name, tr.querySelector('.langSel').value); 
      };
      
      tr.querySelector('.voiceSel').onchange = (e) => { 
        data.voice = e.target.value; 
        saveRoles(); 
        renderRoles(); 
      };
      
      tr.querySelector('.langSel').onchange = (e) => { 
        data.lang = e.target.value; 
        saveRoles(); 
        renderRoles(); 
      };
      
      tr.querySelectorAll('.speedC').forEach(b => 
        b.onclick = () => { 
          data.speed = b.dataset.val; 
          tr.querySelector('.speedNum').value = data.speed; 
          saveRoles(); 
          renderRoles(); 
        }
      );
      
      tr.querySelectorAll('.pitchC').forEach(b => 
        b.onclick = () => { 
          data.pitch = b.dataset.val; 
          tr.querySelector('.pitchNum').value = data.pitch; 
          saveRoles(); 
          renderRoles(); 
        }
      );
      
      tr.querySelectorAll('.volC').forEach(b => 
        b.onclick = () => { 
          data.vol = b.dataset.val; 
          tr.querySelector('.volNum').value = data.vol; 
          saveRoles(); 
          renderRoles(); 
        }
      );
      
      tr.querySelector('.speedNum').oninput = (e) => { 
        data.speed = String(e.target.value || '100'); 
        saveRoles(); 
      };
      
      tr.querySelector('.pitchNum').oninput = (e) => { 
        data.pitch = String(e.target.value || '0'); 
        saveRoles(); 
      };
      
      tr.querySelector('.volNum').oninput = (e) => { 
        data.vol = String(e.target.value || '0'); 
        saveRoles(); 
      };
      
      tr.querySelector('.comfy').onclick = (e) => { 
        const btn = e.currentTarget; 
        const on = btn.getAttribute('aria-pressed') === 'true'; 
        btn.setAttribute('aria-pressed', String(!on)); 
        data.comfy = !on; 
        btn.classList.toggle('btn-primary', !on); 
        btn.classList.toggle('btn-secondary', on); 
        btn.textContent = (!on) ? 'ON' : 'OFF'; 
        if (data.comfy) { 
          data.speed = '92'; 
          data.pitch = '-2'; 
        } 
        saveRoles(); 
        renderRoles(); 
      };
      
      return tr;
    }
    
    function renderBaseVoiceSelect(){
      ensureBaseRole();
      const base = roles._;
      const langs = [...new Set(VOICES.flatMap(v => v.languageCodes || []))].sort();
      const langSel = $('baseLangSel');
      const voiceSel = $('baseVoiceSel');
      const voiceInfo = $('baseVoiceInfo');
      
      if (langSel && langs.length > 0) {
        langSel.innerHTML = langs.map(c => `<option ${base.lang === c ? 'selected' : ''} value="${c}">${c}</option>`).join('');
      }
      
      const curLang = langSel ? langSel.value : base.lang || 'ko-KR';
      const list = VOICES.filter(v => (v.languageCodes || []).includes(curLang));
      
      if (voiceSel) {
        voiceSel.innerHTML = `<option value="" ${!base.voice ? 'selected' : ''}>(선택)</option>` + 
          list.map(v => `<option ${base.voice === v.name ? 'selected' : ''} value="${v.name}">${formatVoiceOption(v)}</option>`).join('');
      }
      
      // 목소리 정보 표시
      if (voiceInfo && base.voice) {
        const selectedVoice = voiceIndex[base.voice];
        if (selectedVoice) {
          voiceInfo.innerHTML = formatVoiceInfo(selectedVoice);
        }
      } else if (voiceInfo) {
        voiceInfo.innerHTML = '';
      }
      
      if (langSel) {
        langSel.onchange = () => { 
          base.lang = langSel.value; 
          saveRoles(); 
          renderBaseVoiceSelect(); 
        };
      }
      
      if (voiceSel) {
        voiceSel.onchange = () => { 
          base.voice = voiceSel.value || ''; 
          saveRoles();
          renderBaseVoiceSelect(); // 정보 업데이트
        };
      }
      
      const previewBtn = $('basePreviewBtn');
      if (previewBtn) {
        previewBtn.onclick = () => {
          const voiceValue = voiceSel ? voiceSel.value || '' : '';
          const langValue = langSel ? langSel.value || 'ko-KR' : 'ko-KR';
          if (!voiceValue) return showError('먼저 목소리를 선택하세요');
          previewVoice(voiceValue, langValue);
        };
      }
    }

    function renderRoles(){ 
      if (!roleBody) return;
      roleBody.innerHTML = ''; 
      ensureBaseRole(); 
      const keys = Object.keys(roles).sort((a, b) => a === '_' ? -1 : (b === '_' ? 1 : a.localeCompare(b))); 
      const roleCount = $('roleCount');
      if (roleCount) {
        roleCount.textContent = `총 ${keys.length}개 이름`; 
      }
      keys.forEach(alias => roleBody.appendChild(roleRow(alias, roles[alias]))); 
    }

    on($('addRoleBtn'), 'click', () => { 
      const name = prompt('추가할 이름 (예: 할머니)'); 
      if (!name) return; 
      roles[name] = {voice: '', speed: '100', pitch: '0', vol: '0', lang: 'ko-KR', comfy: false}; 
      saveRoles(); 
      renderRoles(); 
    });
    
    on($('resetRolesBtn'), 'click', () => { 
      if (!confirm('모든 이름 설정을 초기화할까요?')) return; 
      roles = {}; 
      ensureBaseRole(); 
      saveRoles(); 
      renderRoles(); 
    });

    // 이름 자동찾기
    function parseDialogByAlias(text, resetEachLine){ 
      const lines = text.split(/\n/); 
      const parts = []; 
      let cur = '_'; 
      for (const raw of lines) { 
        const line = raw.trim(); 
        if (!line) { 
          parts.push({alias: resetEachLine ? '_' : cur, text: '\n'}); 
          continue;
        } 
        let m = line.match(/^([\w\uAC00-\uD7A3]{1,16}):\s*(.*)$/); 
        if (m) { 
          cur = m[1]; 
          parts.push({alias: cur, text: m[2]}); 
          if (resetEachLine) cur = '_'; 
          continue;
        } 
        m = line.match(/^\[([\w\uAC00-\uD7A3]{1,16})\]\s*(.*)$/); 
        if (m) { 
          cur = m[1]; 
          parts.push({alias: cur, text: m[2]}); 
          if (resetEachLine) cur = '_'; 
          continue;
        } 
        parts.push({alias: resetEachLine ? '_' : cur, text: line}); 
      }
      return parts.filter(p => p.text && p.text.trim()); 
    }
    
    function detectRoles(){ 
      const parts = parseDialogByAlias(editor.value, $('lineResetTgl').getAttribute('aria-pressed') === 'true'); 
      const uniq = new Set(parts.map(p => p.alias)); 
      ensureBaseRole(); 
      uniq.forEach(a => { 
        if (!roles[a]) roles[a] = {voice: '', speed: '100', pitch: '0', vol: '0', lang: 'ko-KR', comfy: (a === '_')}; 
      }); 
      saveRoles(); 
      renderRoles(); 
      showSuccess(`찾은 이름: ${[...uniq].join(', ')}`); 
    }
    on($('detectBtn'), 'click', detectRoles);

    // 편집 도우미
    on($('aliasBtn'), 'click', () => { 
      const name = prompt('선택한 문장에 붙일 이름 (예: 할머니)'); 
      if (!name) return; 
      const ta = editor; 
      const s = ta.selectionStart, e = ta.selectionEnd; 
      const before = ta.value.slice(0, s), sel = ta.value.slice(s, e), after = ta.value.slice(e); 
      ta.value = `${before}${name}: ${sel}${after}`; 
      updateCounter(); 
    });
    
    on($('altBtn'), 'click', () => { 
      const A = prompt('첫 줄 이름(예: A)'), B = prompt('다음 줄 이름(예: B)'); 
      if (!A || !B) return; 
      const lines = editor.value.split(/\n/); 
      let cur = A; 
      for (let i = 0; i < lines.length; i++) { 
        if (lines[i].trim()) { 
          lines[i] = `${cur}: ` + lines[i]; 
          cur = (cur === A ? B : A);
        } 
      } 
      editor.value = lines.join('\n'); 
      updateCounter(); 
    });

    // 언어 샘플
    const LANG_SAMPLES = [
      { code: 'ko-KR', name: '한국어(대한민국)', sample: '안녕하세요. 이것은 샘플 문장입니다.' },
      { code: 'en-US', name: '영어(미국)', sample: 'Hello, this is a sample sentence.' },
      { code: 'en-GB', name: '영어(영국)', sample: 'Hello, this is a sample sentence.' },
      { code: 'ja-JP', name: '일본어', sample: 'こんにちは。これはサンプル文です。' },
      { code: 'zh-CN', name: '중국어(중국 표준)', sample: '你好。这是一句示例句子。' },
      { code: 'zh-TW', name: '중국어(대만)', sample: '你好。這是一句範例。' },
      { code: 'de-DE', name: '독일어', sample: 'Hallo, dies ist ein Beispielsatz.' },
      { code: 'fr-FR', name: '프랑스어', sample: 'Bonjour, ceci est une phrase exemple.' },
      { code: 'es-ES', name: '스페인어(스페인)', sample: 'Hola, esta es una frase de ejemplo.' },
      { code: 'it-IT', name: '이탈리아어', sample: 'Ciao, questa è una frase di esempio.' },
      { code: 'ru-RU', name: '러시아어', sample: 'Здравствуйте. Это пример предложения.' },
      { code: 'pt-BR', name: '포르투갈어(브라질)', sample: 'Olá, esta é uma frase de exemplo.' }
    ];
    
    const voiceBody = document.querySelector('#voiceTable tbody');
    
    function renderSample(){ 
      const sel = $('sampleLang'); 
      if (!sel) return;
      sel.innerHTML = LANG_SAMPLES.map(x => `<option value="${x.code}">${x.name} — ${x.code}</option>`).join(''); 
      const saved = localStorage.getItem(LS.SAMPLE); 
      sel.value = saved || 'ko-KR'; 
      const it = LANG_SAMPLES.find(x => x.code === sel.value); 
      if (it && $('sampleText')) $('sampleText').value = it.sample; 
      renderVoiceList(); 
    }
    
    on($('sampleLang'), 'change', () => { 
      const sampleLang = $('sampleLang');
      if (!sampleLang) return;
      localStorage.setItem(LS.SAMPLE, sampleLang.value); 
      const it = LANG_SAMPLES.find(x => x.code === sampleLang.value); 
      if (it && $('sampleText')) $('sampleText').value = it.sample; 
      renderVoiceList(); 
    });
    
    function renderVoiceList(){ 
      if (!voiceBody) return;
      voiceBody.innerHTML = ''; 
      const sampleLang = $('sampleLang');
      if (!sampleLang) return;
      const lang = sampleLang.value; 
      const list = VOICES.filter(v => (v.languageCodes || []).includes(lang)); 
      
      list.forEach(v => { 
        const tr = document.createElement('tr'); 
        tr.innerHTML = `
        <td class="mono">${v.name}</td>
        <td>${formatVoiceInfo(v)}</td>
        <td><button class="btn btn-secondary small prevBtn">▶</button></td>
        <td><button class="btn btn-secondary small useBase">기본 이름</button></td>
        <td><button class="btn btn-secondary small useSelected">선택 이름…</button></td>`;
        
        tr.querySelector('.prevBtn').onclick = () => {
          const sampleText = $('sampleText');
          previewVoice(v.name, lang, sampleText ? sampleText.value : '안녕하세요. 미리듣기입니다.');
        };
        
        tr.querySelector('.useBase').onclick = () => { 
          ensureBaseRole(); 
          roles._.lang = lang; 
          roles._.voice = v.name; 
          saveRoles(); 
          renderRoles(); 
          renderBaseVoiceSelect();
          showSuccess('기본 이름에 적용됨'); 
        };
        
        tr.querySelector('.useSelected').onclick = () => { 
          const keys = Object.keys(roles); 
          if (!keys.length) { 
            showError('먼저 이름을 추가하세요'); 
            return; 
          } 
          const name = prompt('어느 이름에 쓸까요? ' + keys.join(', ')); 
          if (!name || !roles[name]) return; 
          roles[name].lang = lang; 
          roles[name].voice = v.name; 
          saveRoles(); 
          renderRoles(); 
          showSuccess(`${name}에 적용됨`); 
        };
        
        voiceBody.appendChild(tr); 
      }); 
    }

    // 수정: MAX_BYTES 값 낮춤 (안전 마진 확보)
    const MAX_BYTES = 4750;
    
    // 수정: splitChunks 함수 - 청크 간 break 추가 로직 제거
    function splitChunks(text){ 
      const out = []; 
      const paras = text.split(/\n{2,}/); 
      for (const para of paras) { 
        if (!para.trim()) continue; 
        if (bCount(para) <= MAX_BYTES) { 
          out.push(para); 
          continue;
        } 
        const sents = para.split(/(?<=[\.\!\?\…]|[。！？])\s+/); 
        let buf = ''; 
        for (const s of sents) { 
          const cand = buf ? (buf + ' ' + s) : s; 
          if (bCount(cand) > MAX_BYTES) { 
            if (buf) out.push(buf); 
            if (bCount(s) > MAX_BYTES) { 
              let cur = s; 
              while (bCount(cur) > MAX_BYTES) { 
                let take = Math.floor(cur.length * 0.6); 
                while (take < cur.length && bCount(cur.slice(0, take)) <= MAX_BYTES) take++; 
                out.push(cur.slice(0, take - 1)); 
                cur = cur.slice(take - 1);
              } 
              if (cur.trim()) buf = cur; 
              else buf = ''; 
            } else { 
              buf = s; 
            } 
          } else { 
            buf = cand; 
          } 
        } 
        if (buf.trim()) out.push(buf);
      } 
      
      return out; 
    }
    
    function insertBreaks(str, ms, useSSML = true){ 
      if (!ms || ms === '0' || !useSSML) return str; 
      const parts = str.split(/(?<=[\.\!\?\…]|[。！？])\s+/); 
      return parts.join(` <break time="${ms}ms"/> `); 
    }

    async function synthesizeChunk({text, useSSML, voiceName, languageCode, rate, pitch, vol, encoding, sampleRate, effectsProfile}){
      const key = localStorage.getItem(LS.KEY); 
      if (!key) throw new Error('API 키가 없습니다');
      
      const voice = { languageCode }; 
      if (voiceName) voice.name = voiceName;
      
      const audioConfig = { 
        audioEncoding: encoding, 
        speakingRate: rate, 
        pitch: pitch, 
        volumeGainDb: vol, 
        sampleRateHertz: sampleRate 
      };
      
      // 오디오 효과 프로필 추가
      if (effectsProfile) {
        audioConfig.effectsProfileId = [effectsProfile];
      }
      
      const url = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${encodeURIComponent(key)}`;
      const retries = Number($('retrySelect') ? $('retrySelect').value : '3');
      
      for (let attempt = 0; attempt <= retries; attempt++) {
        if (cancelRequested) throw new Error('사용자가 취소함');
        
        if (useSSML) {
          const ssmlBody = { 
            input: { ssml: `<speak>${text}</speak>` }, 
            voice, 
            audioConfig 
          };
          
          try {
            const r = await fetch(url, {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify(ssmlBody)
            });
            const j = await r.json();
            
            if (r.ok) return j.audioContent;
            
            if (j.error?.message?.includes('does not support SSML')) {
              console.warn('SSML 미지원 음성, 텍스트 모드로 전환:', voiceName);
              const textBody = { 
                input: { text: text.replace(/<[^>]*>/g, '') },
                voice, 
                audioConfig 
              };
              
              const r2 = await fetch(url, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(textBody)
              });
              const j2 = await r2.json();
              if (r2.ok) return j2.audioContent;
              if (attempt === retries) throw new Error(j2.error?.message || r2.statusText);
            } else {
              if (attempt === retries) throw new Error(j.error?.message || r.statusText);
            }
          } catch (fetchError) {
            if (attempt === retries) throw fetchError;
          }
        } else {
          const textBody = { 
            input: { text }, 
            voice, 
            audioConfig 
          };
          
          try {
            const r = await fetch(url, {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify(textBody)
            });
            const j = await r.json();
            if (r.ok) return j.audioContent;
            if (attempt === retries) throw new Error(j.error?.message || r.statusText);
          } catch (fetchError) {
            if (attempt === retries) throw fetchError;
          }
        }
        
        await sleep(300 * (attempt + 1));
      }
    }
    
    function b64ToU8(b64){ 
      const bin = atob(b64); 
      const u8 = new Uint8Array(bin.length); 
      for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i); 
      return u8; 
    }
    
    function concatWavFiles(wavArrays, sampleRate = 44100) {
      if (wavArrays.length === 0) return new Uint8Array();
      if (wavArrays.length === 1) return wavArrays[0];
      
      const WAV_HEADER_SIZE = 44;
      const audioDataArrays = wavArrays.map(wav => wav.slice(WAV_HEADER_SIZE));
      const totalAudioLength = audioDataArrays.reduce((sum, data) => sum + data.length, 0);
      const totalFileSize = WAV_HEADER_SIZE + totalAudioLength;
      
      const result = new Uint8Array(totalFileSize);
      const view = new DataView(result.buffer);
      
      // RIFF 헤더
      view.setUint32(0, 0x52494646, false); // "RIFF"
      view.setUint32(4, totalFileSize - 8, true);
      view.setUint32(8, 0x57415645, false); // "WAVE"
      
      // fmt 청크
      view.setUint32(12, 0x666d7420, false); // "fmt "
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true);
      view.setUint16(32, 2, true);
      view.setUint16(34, 16, true);
      
      // data 청크
      view.setUint32(36, 0x64617461, false); // "data"
      view.setUint32(40, totalAudioLength, true);
      
      let offset = WAV_HEADER_SIZE;
      for (const audioData of audioDataArrays) {
        result.set(audioData, offset);
        offset += audioData.length;
      }
      
      return result;
    }

    function concatU8(arrs, encoding = 'MP3', sampleRate = 44100){ 
      if (arrs.length === 0) return new Uint8Array();
      if (arrs.length === 1) return arrs[0];
      
      if (encoding === 'LINEAR16') {
        return concatWavFiles(arrs, sampleRate);
      }
      
      const totalSize = arrs.reduce((s, a) => s + a.length, 0);
      const out = new Uint8Array(totalSize); 
      let offset = 0; 
      for (const arr of arrs) { 
        out.set(arr, offset); 
        offset += arr.length;
      } 
      
      return out; 
    }

    async function previewVoice(name, lang, sample){ 
      try { 
        const sampleRate = Number($('sampleRateSelect') ? $('sampleRateSelect').value : '44100');
        const b64 = await synthesizeChunk({
          text: sample || '안녕하세요. 미리듣기입니다.', 
          useSSML: false, 
          voiceName: name, 
          languageCode: lang || 'ko-KR', 
          rate: 1.0, 
          pitch: 0, 
          vol: 0, 
          encoding: 'MP3', 
          sampleRate: sampleRate
        }); 
        const url = URL.createObjectURL(new Blob([b64ToU8(b64)], {type: 'audio/mpeg'})); 
        new Audio(url).play(); 
      } catch (e) { 
        showError('미리듣기 실패: ' + parseError(e));
      } 
    }

    // 수정: buildSegments 함수 완전 재작성
    function buildSegments(){ 
      const text = editor.value; 
      const enc = $('encodingSelect') ? $('encodingSelect').value : 'MP3';
      const sr = Number($('sampleRateSelect') ? $('sampleRateSelect').value : '44100');
      const sp = $('sentenceBreakSelect') ? $('sentenceBreakSelect').value : '300';
      const sw = $('switchSelect') ? $('switchSelect').value : '150';
      const lineReset = $('lineResetTgl') ? $('lineResetTgl').getAttribute('aria-pressed') === 'true' : true;
      const chunkOn = $('chunkTgl') ? $('chunkTgl').getAttribute('aria-pressed') === 'true' : true;
      const effectsProfile = $('effectsProfileSel') ? $('effectsProfileSel').value : '';
      
      const segs = []; 
      
      // 수정: splitChunks는 순수하게 분할만 수행 (break 태그 추가 안 함)
      const splitter = chunkOn ? (t) => splitChunks(t) : (t) => [t];
      
      if (mode === 'ssml') {
        const chunks = splitter(text);
        const base = roles._ || {voice: '', speed: '100', pitch: '0', vol: '0', lang: 'ko-KR'};
        chunks.forEach((ch, idx) => {
          // 청크 간 연결 break (마지막 제외)
          const chunkBreak = (idx < chunks.length - 1) ? ` <break time="${sp}ms"/>` : '';
          segs.push({ 
            alias: '기본', 
            text: ch + chunkBreak, 
            ssml: true, 
            voice: base.voice, 
            lang: base.lang, 
            rate: Number(base.speed) / 100, 
            pitch: Number(base.pitch), 
            vol: Number(base.vol),
            effectsProfile: effectsProfile
          });
        });
      } else if (mode === 'plain') {
        const base = roles._ || {voice: '', speed: '100', pitch: '0', vol: '0', lang: 'ko-KR'};
        const plainSpeed = $('plainSpeedSlider') ? Number($('plainSpeedSlider').value) / 100 : Number(base.speed) / 100;
        const plainPitch = $('plainPitchSlider') ? Number($('plainPitchSlider').value) : Number(base.pitch);
        const plainVolume = $('plainVolumeSlider') ? Number($('plainVolumeSlider').value) : Number(base.vol);
        
        const isAdvancedVoice = base.voice && (base.voice.includes('Neural') || base.voice.includes('Wavenet') || base.voice.includes('Chirp'));
        
        // 수정: 먼저 청크로 나누고, 각 청크에 break 추가
        const chunks = splitter(text);
        chunks.forEach((ch, idx) => {
          const inner = insertBreaks(ch, sp, isAdvancedVoice);
          // 마지막 청크가 아니면 청크 끝에 break 추가
          const chunkBreak = (idx < chunks.length - 1 && isAdvancedVoice) ? ` <break time="${sp}ms"/>` : '';
          
          segs.push({ 
            alias: '기본', 
            text: inner + chunkBreak, 
            ssml: isAdvancedVoice, 
            voice: base.voice, 
            lang: base.lang, 
            rate: plainSpeed, 
            pitch: plainPitch, 
            vol: plainVolume,
            effectsProfile: effectsProfile
          });
        });
      } else { // dialog
        const parts = parseDialogByAlias(text, lineReset);
        
        // 수정: 먼저 역할별로 텍스트를 그룹화
        let currentAlias = parts[0]?.alias || '_';
        let buffer = '';
        const roleGroups = [];
        
        for (let i = 0; i < parts.length; i++) {
          const cur = parts[i];
          const next = parts[i + 1];
          
          if (cur.alias !== currentAlias) {
            // 역할이 바뀌면 이전 버퍼 저장
            if (buffer) {
              roleGroups.push({alias: currentAlias, text: buffer, isLast: false});
              buffer = '';
            }
            currentAlias = cur.alias;
          }
          
          buffer += (buffer ? ' ' : '') + cur.text;
          
          // 다음 역할이 다르거나 마지막이면 저장
          if (!next || next.alias !== currentAlias) {
            roleGroups.push({alias: currentAlias, text: buffer, isLast: !next});
            buffer = '';
            if (next) currentAlias = next.alias;
          }
        }
        
        // 각 역할 그룹을 청크로 분할하고 세그먼트 생성
        roleGroups.forEach((group, groupIdx) => {
          const r = roles[group.alias] || roles._ || {voice: '', speed: '100', pitch: '0', vol: '0', lang: 'ko-KR'};
          const isAdvancedVoice = r.voice && (r.voice.includes('Neural') || r.voice.includes('Wavenet') || r.voice.includes('Chirp'));
          
          const chunks = splitter(group.text);
          chunks.forEach((ch, chunkIdx) => {
            const inner = insertBreaks(ch, sp, isAdvancedVoice);
            
            // break 태그 결정
            let endBreak = '';
            if (chunkIdx < chunks.length - 1) {
              // 같은 역할 내 청크 간
              endBreak = isAdvancedVoice ? ` <break time="${sp}ms"/>` : '';
            } else if (!group.isLast) {
              // 역할 전환
              endBreak = isAdvancedVoice ? ` <break time="${sw}ms"/>` : '';
            }
            
            segs.push({ 
              alias: group.alias, 
              text: inner + endBreak, 
              ssml: isAdvancedVoice, 
              voice: r.voice, 
              lang: r.lang, 
              rate: Number(r.speed) / 100, 
              pitch: Number(r.pitch), 
              vol: Number(r.vol),
              effectsProfile: effectsProfile
            });
          });
        });
      }
      
      return {segs, enc, sr};
    }

    // 취소 버튼
    on($('cancelBtn'), 'click', () => {
      cancelRequested = true;
      $('cancelBtn').style.display = 'none';
    });
    
    on($('makeBtn'), 'click', async () => {
      if (!localStorage.getItem(LS.KEY)) return showError('먼저 API 키를 저장하세요');
      if (VOICES.length === 0) await loadVoices();
      
      if (mode !== 'ssml') {
        if (mode === 'plain') { 
          if (!(roles._ && roles._.voice)) return showError('일반 모드: 기본 이름의 목소리를 먼저 선택하세요'); 
        }
        if (mode === 'dialog') {
          const missing = []; 
          Object.keys(roles).forEach(k => { 
            if (!roles[k].voice) missing.push(k); 
          }); 
          if (missing.length > 0) return showError('아래 이름 설정표에서 목소리를 선택하세요:\n' + missing.join(', '));
        }
      }
      
      const makeBtn = $('makeBtn');
      const cancelBtn = $('cancelBtn');
      const status = $('status');
      const progressBar = $('progressBar');
      const progressFill = $('progressFill');
      
      makeBtn.disabled = true; 
      cancelBtn.style.display = 'inline';
      progressBar.style.display = 'block';
      cancelRequested = false;
      status.textContent = '시작합니다…';
      
      // 이전 오디오 URL 정리
      activeAudioUrls.forEach(url => URL.revokeObjectURL(url));
      activeAudioUrls = [];
      
      try {
        const {segs, enc, sr} = buildSegments();
        const parts = []; 
        
        for (let i = 0; i < segs.length; i++) {
          if (cancelRequested) {
            throw new Error('사용자가 취소함');
          }
          
          status.textContent = `만드는 중… (${i + 1}/${segs.length})`;
          progressFill.style.width = `${((i + 1) / segs.length) * 100}%`;
          
          const s = segs[i];
          const b64 = await synthesizeChunk({
            text: s.text, 
            useSSML: s.ssml, 
            voiceName: s.voice, 
            languageCode: s.lang, 
            rate: s.rate, 
            pitch: s.pitch, 
            vol: s.vol, 
            encoding: enc, 
            sampleRate: sr,
            effectsProfile: s.effectsProfile
          });
          const u8 = b64ToU8(b64); 
          parts.push(u8);
          await sleep(8);
        }
        
        const bytes = concatU8(parts, enc, sr); 
        const mime = (enc === 'OGG_OPUS' ? 'audio/ogg' : (enc === 'LINEAR16' ? 'audio/wav' : 'audio/mpeg')); 
        const url = URL.createObjectURL(new Blob([bytes], {type: mime}));
        activeAudioUrls.push(url);
        
        const player = $('player');
        if (player) player.src = url; 
        
        const ext = (enc === 'OGG_OPUS' ? 'ogg' : (enc === 'LINEAR16' ? 'wav' : 'mp3'));
        const name = `tts-output-${new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-')}.${ext}`; 
        const dl = $('download'); 
        if (dl) {
          dl.style.display = 'inline'; 
          dl.href = url; 
          dl.download = name; 
        }
        
        const outInfo = $('outInfo');
        if (outInfo) {
          outInfo.textContent = `${(bytes.length / 1024).toFixed(1)} KB · ${segs.length} 조각`; 
        }
        status.textContent = '완료';
        progressFill.style.width = '100%';
      } catch (e) { 
        console.error(e); 
        showError('오류: ' + parseError(e)); 
        status.textContent = '실패'; 
        progressFill.style.width = '0%';
      }
      
      makeBtn.disabled = false;
      cancelBtn.style.display = 'none';
      setTimeout(() => {
        progressBar.style.display = 'none';
      }, 2000);
    });

    // 모두 듣기 편하게 버튼
    on($('seniorAllBtn'), 'click', () => {
      if (!confirm('모든 이름을 듣기 편한 설정(속도 92%, 톤 -2)으로 변경할까요?')) return;
      Object.keys(roles).forEach(alias => {
        roles[alias].speed = '92';
        roles[alias].pitch = '-2';
        roles[alias].comfy = true;
      });
      saveRoles();
      renderRoles();
      showSuccess('모든 이름이 듣기 편한 설정으로 변경되었습니다');
    });

    // 초기화
    (async function init(){ 
      updateApiBadge(); 
      setMode(mode);
      const o = loadOpts();
      
      // 옵션 복원
      if ($('encodingSelect')) $('encodingSelect').value = o.encoding || 'MP3';
      if ($('sampleRateSelect')) $('sampleRateSelect').value = o.sampleRate || '44100';
      if ($('sentenceBreakSelect')) $('sentenceBreakSelect').value = o.sentenceBreak || '300';
      if ($('switchSelect')) $('switchSelect').value = o.switchDelay || '150';
      if ($('retrySelect')) $('retrySelect').value = o.retry || '3';
      if ($('effectsProfileSel')) $('effectsProfileSel').value = o.effectsProfile || '';
      
      const normTgl = $('normTgl');
      if (normTgl) {
        normTgl.setAttribute('aria-pressed', String(o.norm !== false)); 
        normTgl.classList.toggle('btn-primary', o.norm !== false); 
        normTgl.classList.toggle('btn-secondary', o.norm === false); 
        normTgl.textContent = (o.norm === false ? 'OFF' : 'ON');
      }
      
      const chunkTgl = $('chunkTgl');
      if (chunkTgl) {
        chunkTgl.setAttribute('aria-pressed', String(o.chunk !== false)); 
        chunkTgl.classList.toggle('btn-primary', o.chunk !== false); 
        chunkTgl.classList.toggle('btn-secondary', o.chunk === false); 
        chunkTgl.textContent = (o.chunk === false ? 'OFF' : 'ON');
      }
      
      const lineResetTgl = $('lineResetTgl');
      if (lineResetTgl) {
        lineResetTgl.setAttribute('aria-pressed', String(o.lineReset !== false)); 
        lineResetTgl.classList.toggle('btn-primary', o.lineReset !== false); 
        lineResetTgl.classList.toggle('btn-secondary', o.lineReset === false); 
        lineResetTgl.textContent = (o.lineReset === false ? 'OFF' : 'ON');
      }
      
      // 일반 모드 슬라이더 복원
      if ($('plainSpeedSlider')) {
        $('plainSpeedSlider').value = o.plainSpeed || '100';
        $('plainSpeedValue').textContent = (o.plainSpeed || '100') + '%';
      }
      if ($('plainPitchSlider')) {
        $('plainPitchSlider').value = o.plainPitch || '0';
        $('plainPitchValue').textContent = o.plainPitch || '0';
      }
      if ($('plainVolumeSlider')) {
        $('plainVolumeSlider').value = o.plainVolume || '0';
        $('plainVolumeValue').textContent = (o.plainVolume || '0') + 'dB';
      }
      
      // API 키 복원
      const savedKey = localStorage.getItem(LS.KEY);
      if (savedKey && apiKey) {
        apiKey.value = savedKey;
      }
      
      try {
        await loadVoices(); 
      } catch (e) {
        console.warn('음성 로드 실패:', e.message);
      }
      
      ensureBaseRole(); 
      renderRoles(); 
      renderSample(); 
      renderBaseVoiceSelect(); 
      updateCounter(); 
      autosave();
      
      // 페이지 떠날 때 메모리 정리
      window.addEventListener('beforeunload', () => {
        activeAudioUrls.forEach(url => URL.revokeObjectURL(url));
      });
    })();

    // 전역 함수로 노출 (HTML에서 호출용)
    window.setPlainSpeed = setPlainSpeed;
    window.setPlainPitch = setPlainPitch;
    window.setPlainVolume = setPlainVolume;
  </script>
</body>
</html>