<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>30줄마다 [a]/[b] 자동 태깅</title>
  <style>
    body { font-family: sans-serif; background: #f9fafb; margin: 0; padding: 20px; }
    textarea { width: 100%; border-radius: 12px; border: 1px solid #ccc; padding: 10px; }
    .panel { background: white; border-radius: 16px; padding: 16px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .btn { padding: 8px 16px; border-radius: 8px; border: 1px solid #000; cursor: pointer; margin-right: 8px; }
    .btn-primary { background: black; color: white; }
  </style>
</head>
<body>
  <h1>30줄마다 [a]/[b] 자동 태깅</h1>
  <div class="panel">
    <label>원본 텍스트</label>
    <textarea id="inputText" rows="15" placeholder="여기에 텍스트를 붙여넣으세요..."></textarea>
  </div>
  <div class="panel">
    <label>줄 간격 (기본 30)</label>
    <input type="number" id="interval" value="30" min="1" /><br><br>
    <label>첫 블록 태그</label>
    <input type="text" id="tagA" value="[a]" />
    <label>다음 블록 태그</label>
    <input type="text" id="tagB" value="[b]" /><br><br>
    <label><input type="checkbox" id="skipEmpty" /> 빈 줄 건너뛰기</label><br>
    <label><input type="checkbox" id="applyToWholeBlock" /> 블록 전체에 태그 붙이기</label><br><br>
    <button class="btn btn-primary" onclick="processText()">변환하기</button>
    <button class="btn" onclick="copyResult()">결과 복사</button>
    <button class="btn" onclick="downloadResult()">.txt 저장</button>
  </div>
  <div class="panel">
    <label>결과 미리보기</label>
    <textarea id="outputText" rows="15" readonly></textarea>
  </div>

<script>
function processText() {
  const input = document.getElementById('inputText').value;
  const interval = parseInt(document.getElementById('interval').value, 10);
  const tagA = document.getElementById('tagA').value;
  const tagB = document.getElementById('tagB').value;
  const skipEmpty = document.getElementById('skipEmpty').checked;
  const applyToWholeBlock = document.getElementById('applyToWholeBlock').checked;

  const lines = input.split(/\r?\n/);
  const out = [...lines];

  if (applyToWholeBlock) {
    for (let i = 0; i < out.length; i++) {
      const blockIndex = Math.floor(i / interval);
      const tag = blockIndex % 2 === 0 ? tagA : tagB;
      if (skipEmpty && out[i].trim() === '') continue;
      out[i] = tag + ' ' + out[i];
    }
  } else {
    for (let i = 0; i < out.length; i++) {
      if (i % interval === 0) {
        const blockIndex = Math.floor(i / interval);
        const tag = blockIndex % 2 === 0 ? tagA : tagB;
        if (skipEmpty && out[i].trim() === '') {
          for (let j = i; j < Math.min(i + interval, out.length); j++) {
            if (out[j].trim() !== '') { out[j] = tag + ' ' + out[j]; break; }
          }
        } else {
          out[i] = tag + ' ' + out[i];
        }
      }
    }
  }

  document.getElementById('outputText').value = out.join('\n');
}

function copyResult() {
  const text = document.getElementById('outputText').value;
  navigator.clipboard.writeText(text);
  alert('결과가 클립보드에 복사되었습니다!');
}

function downloadResult() {
  const text = document.getElementById('outputText').value;
  const blob = new Blob([text], {type: 'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'tagged_text.txt';
  a.click();
  URL.revokeObjectURL(url);
}
</script>
</body>
</html>
